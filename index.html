
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  
  <title>hankliu小博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="我们在梦里走过许多路，醒来后却发现自己还在床上。">
<meta property="og:type" content="website">
<meta property="og:title" content="hankliu小博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="hankliu小博客">
<meta property="og:description" content="我们在梦里走过许多路，醒来后却发现自己还在床上。">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="hankliu小博客">
<meta name="twitter:description" content="我们在梦里走过许多路，醒来后却发现自己还在床上。">
  
    <link rel="alternative" href="/atom.xml" title="hankliu小博客" type="application/atom+xml">
  
  
    <link rel="icon" href="http://oiq00n80p.bkt.clouddn.com/favicons_2_16.png" sizes="16x16">
  
  <link rel="stylesheet" href="/css/style.css">
  
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
  

</head>

<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <nav id="upper-nav" class="inner">
      <a id="main-nav-toggle" class="nav-icon"></a>
      <div class="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        
          <a id="nav-github" class="nav-icon" href="https://github.com/biluo62"></a>
        
      </div>
    </nav>
    <div id="header-title">
      
        <h1 id="blog-title-wrap">
          <a href="/" id="blog-title">hankliu</a>
        </h1>
      
      
        <h5 class="blog-subtitle-wrap">我们在梦里走过许多路，醒来后却发现自己还在床上。</h5>
      
    </div>
    <div id="contenedor">
      <ul class="cube">
        <li class="cara"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="100" width="100" viewBox="-50 -50 200 200">
          <circle cx="50" cy="50" r="45" stroke-width="5" stroke="black" stroke-opacity="0.5" fill-opacity="0"></circle>
          <rect x="47.5" y="27.5" width="5" height="25" rx="2.5" ry="2.5" fill="black" fill-opacity="0.5" transform="rotate(330 50 50)"></rect>
          <rect x="48.5" y="16.5" width="3" height="35" rx="1.5" ry="1.5" fill="black" fill-opacity="0.5"></rect>
        </svg></li>
        <li class="cara">L</li>
        <li class="cara">X</li>
        <li class="cara">P</li>
        <li class="cara">C</li>
        <li class="cara">Y</li>
      </ul>
    </div>
    <nav id="main-nav">
      
        <a class="main-nav-link" href="/">Home</a>
      
        <a class="main-nav-link" href="/archives">Archives</a>
      
        <a class="main-nav-link" href="/about">About</a>
      
      <a class="main-nav-link st-search-show-outputs">Search</a>
    </nav>
  </div>
</header>

    <div class="outer">
      <section id="main">
  
    <article id="post-hexo-github-blog-guide" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2017/09/09/hexo-github-blog-guide/" class="article-date">
  <time datetime="2017-09-09T00:40:29.000Z" itemprop="datePublished">2017-09-09</time>
</h3>
    
  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/09/hexo-github-blog-guide/">MAC搭建个人博客hexo+github详细完整步骤</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <p>自己也算是摸爬滚打搭建成功，然后自己再重新安装部署一遍，把完整步骤分享给大家，同时最后有一些连接，如果我的步骤不行，大家可以参考其他人的.</p>
<h2 id="一、安装Homebrew"><a href="#一、安装Homebrew" class="headerlink" title="一、安装Homebrew"></a>一、安装Homebrew</h2><p>Homebrew是基于Ruby的，所以安装过程也是很简单的，把下面的代码粘贴到Terminal中执行</p>
<pre><code class="sh">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre>
<p>查看安装是否成功:</p>
<pre><code class="sh">brew --version
</code></pre>
<p>如下图所示表示安装成功</p>
<p><img src="https://user-images.githubusercontent.com/8088864/30236069-ba7e712e-9544-11e7-910a-7ec04c1d5579.png" alt="image"></p>
<p>更多的brew命令</p>
<pre><code class="sh">//查看brew的帮助
brew –help

//安装软件
brew install git

//卸载软件
brew uninstall git

//搜索软件
brew search git

//显示已经安装软件列表
brew list

//更新软件，把所有的Formula目录更新，并且会对本机已经安装并有更新的软件用*标明。
brew update

//更新某具体软件
brew upgrade git

//查看软件信息
brew [info | home] [FORMULA...]

//删除程序，和upgrade一样，单个软件删除和所有程序老版删除。
brew cleanup git
brew cleanup

//查看那些已安装的程序需要更新
brew outdated


//其它Homebrew指令:
brew list   //—列出已安装的软件

brew update   //—更新Homebrew

brew home *   //—用浏览器打开

brew info *   //—显示软件内容信息

brew deps *    //—显示包依赖

brew server *  //—启动web服务器，可以通过浏览器访问
                 //http://localhost:4567/ 来同网页来管理包

brew -h brew   //—帮助
</code></pre>
<h2 id="二、安装Git"><a href="#二、安装Git" class="headerlink" title="二、安装Git"></a>二、安装Git</h2><h3 id="1、使用brew安装Git"><a href="#1、使用brew安装Git" class="headerlink" title="1、使用brew安装Git"></a>1、使用brew安装Git</h3><pre><code class="sh">brew install git
</code></pre>
<h3 id="2、完成安装"><a href="#2、完成安装" class="headerlink" title="2、完成安装"></a>2、完成安装</h3><p>查看是否安装成功</p>
<pre><code class="sh">git --version
</code></pre>
<p><img src="https://user-images.githubusercontent.com/8088864/30236377-b5343392-954a-11e7-9566-927e43ec4983.png" alt="Git安装成功"></p>
<h2 id="三、通过nvm安装指定版本的node"><a href="#三、通过nvm安装指定版本的node" class="headerlink" title="三、通过nvm安装指定版本的node"></a>三、通过nvm安装指定版本的node</h2><h3 id="1、安装nvm"><a href="#1、安装nvm" class="headerlink" title="1、安装nvm"></a>1、安装nvm</h3><pre><code class="sh">brew install nvm
</code></pre>
<h3 id="2、配置nvm"><a href="#2、配置nvm" class="headerlink" title="2、配置nvm"></a>2、配置nvm</h3><p>配置nvm在shell中可以使用nvm命令，修改<code>~/.bash_profile</code>文件，如果不存在，新建<code>.bash_profile</code>文件</p>
<pre><code class="sh">cd ~
vim .bash_profile
</code></pre>
<p>在文件中添加如下命令:</p>
<pre><code class="bash_profile">export NVM_DIR=~/.nvm
source $(brew --prefix nvm)/nvm.sh
</code></pre>
<p>重新source</p>
<pre><code class="sh">source .bash_profile
</code></pre>
<h3 id="3、安装node"><a href="#3、安装node" class="headerlink" title="3、安装node"></a>3、安装node</h3><pre><code class="sh">nvm ls-remote 查看 所有的node可用版本

nvm install xxx 下载你想要的版本

nvm use xxx 使用指定版本的node

nvm alias default xxx 每次启动终端都使用该版本的node
</code></pre>
<h3 id="4、完成安装"><a href="#4、完成安装" class="headerlink" title="4、完成安装"></a>4、完成安装</h3><p>查看是否安装成功</p>
<pre><code class="sh">node -v
npm -v
</code></pre>
<p><img src="https://user-images.githubusercontent.com/8088864/30236355-4d1f8f18-954a-11e7-8da7-54d3f9ae1c91.png" alt="Node安装成功"></p>
<h2 id="四、安装hexo"><a href="#四、安装hexo" class="headerlink" title="四、安装hexo"></a>四、安装hexo</h2><h3 id="1、利用npm命令即可安装"><a href="#1、利用npm命令即可安装" class="headerlink" title="1、利用npm命令即可安装"></a>1、利用npm命令即可安装</h3><p>全局安装</p>
<pre><code class="sh">npm install -g hexo
</code></pre>
<h2 id="五、初始化Hexo"><a href="#五、初始化Hexo" class="headerlink" title="五、初始化Hexo"></a>五、初始化Hexo</h2><h3 id="1、创建Blog所在的文件夹"><a href="#1、创建Blog所在的文件夹" class="headerlink" title="1、创建Blog所在的文件夹"></a>1、创建Blog所在的文件夹</h3><pre><code class="sh">cd /Users/**/Workspace/github
mdkir hankliu62.github.com
</code></pre>
<h3 id="2、hexo初始化"><a href="#2、hexo初始化" class="headerlink" title="2、hexo初始化"></a>2、hexo初始化</h3><pre><code class="sh">hexo init
</code></pre>
<p>初始化成功后会生成如下文件</p>
<p><img src="https://user-images.githubusercontent.com/8088864/30236442-e26003fe-954b-11e7-9313-89dca90d1984.png" alt="Hexo初始化成功"></p>
<h3 id="3、在-config-yml进行基础配置"><a href="#3、在-config-yml进行基础配置" class="headerlink" title="3、在_config.yml进行基础配置"></a>3、在_config.yml进行基础配置</h3><p>配置<em>title</em>, <em>author</em>, <em>description</em>等基本信息</p>
<p><img src="https://user-images.githubusercontent.com/8088864/30236472-81f5d998-954c-11e7-9512-4e9fa6aa14fe.png" alt="基础配置"></p>
<h3 id="4、设置主题"><a href="#4、设置主题" class="headerlink" title="4、设置主题"></a>4、设置主题</h3><p>可以<a href="https://hexo.io/themes/" target="_blank" rel="external">Hexo主题</a>页面中选择与自己相匹配的主题，使用Git clone到themes目录下，配置成自己博客的主题, 这些主题都是安装作者的喜好来开发的，我们可以Fork这个project，根据自己的喜好来进行二次开发和设置</p>
<pre><code class="sh">cd themes

https://github.com/hankliu62/hexo-theme-paperbox.git
</code></pre>
<h3 id="5、添加博客文章"><a href="#5、添加博客文章" class="headerlink" title="5、添加博客文章"></a>5、添加博客文章</h3><p>源文件一般为markdown文件，所以在写博客之前我们需要先了解<a href="http://www.appinn.com/markdown/" target="_blank" rel="external">markdown的基本语法</a>, 将完成的文章放到<code>source/_posts</code>路径下。</p>
<p><img src="https://user-images.githubusercontent.com/8088864/30236636-63a2de56-9550-11e7-9ff4-3efba9c58b14.png" alt="文章"></p>
<h3 id="6、启动本地服务，浏览本地博客"><a href="#6、启动本地服务，浏览本地博客" class="headerlink" title="6、启动本地服务，浏览本地博客"></a>6、启动本地服务，浏览本地博客</h3><pre><code class="sh">hexo g

hexo s
</code></pre>
<p>更多<a href="https://segmentfault.com/a/1190000002632530" target="_blank" rel="external">hexo命令</a></p>
<pre><code class="sh"># 启动服务
hexo server # Hexo 会监视文件变动并自动更新，您无须重启服务器。
hexo s # 简写
hexo server
hexo server -s # 静态模式
hexo server -p 5000 # 更改端口
hexo server -i 192.168.1.1 # 自定义 IP
# INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.

#清除缓存
hexo clean #网页正常情况下可以忽略此条命令
# INFO  Deleted database.
# INFO  Deleted public folder.

# 新建文件夹（自动在文件夹下新建index.md）
hexo new page &quot;file&quot;
# INFO Created: D:...\blog\source\file\index.md

# 新建文章
hexo n fileName
hexo new &quot;fileName&quot;
hexo new post fileName
hexo new post &quot;fileName&quot;
# INFO Created: D:...\blog\source\_posts\fileName.md

# 生成/编译/发布(生成静态网页)
hexo generate
hexo g
hexo generate --watch # 监视文件变动
# INFO Files loaded in 2.03 s
# INFO Deleted: ......
# INFO Generated: ......
# INFO 108 files generatd in 8.44 s

# 部署
hexo deploy
hexo d

# 完成后部署(两个命令的作用是相同的)
hexo generate --deploy
hexo deploy --generate
hexo deploy -g
hexo server -g
</code></pre>
<h3 id="7、浏览器输入http-localhost-4000进行访问"><a href="#7、浏览器输入http-localhost-4000进行访问" class="headerlink" title="7、浏览器输入http://localhost:4000进行访问"></a>7、浏览器输入<code>http://localhost:4000</code>进行访问</h3><p><img src="https://user-images.githubusercontent.com/8088864/30236643-a79dff46-9550-11e7-888e-2dbfe2cf3773.png" alt="博客"></p>
<h2 id="六、部署到Github"><a href="#六、部署到Github" class="headerlink" title="六、部署到Github"></a>六、部署到Github</h2><h3 id="1、申请Github账号"><a href="#1、申请Github账号" class="headerlink" title="1、申请Github账号"></a>1、申请Github账号</h3><h3 id="2、New-repository"><a href="#2、New-repository" class="headerlink" title="2、New repository"></a>2、New repository</h3><p><img src="https://user-images.githubusercontent.com/8088864/30236675-5734e9ec-9551-11e7-8ecc-e38b4e0d98e8.png" alt="New repository"></p>
<p>注意: 输入<code>Repository name</code>时，最好与前面的<code>username</code>保持一致(上图不一致是因为我已经使用<code>hankliu62.github.com</code>创建了一个github仓库了)</p>
<h3 id="3、选择hankliu62-hankliu62-github-com-gt-gt-Settings-gt-gt-GitHub-Pages-gt-gt-Choose-a-theme"><a href="#3、选择hankliu62-hankliu62-github-com-gt-gt-Settings-gt-gt-GitHub-Pages-gt-gt-Choose-a-theme" class="headerlink" title="3、选择hankliu62/hankliu62.github.com &gt;&gt; Settings &gt;&gt; GitHub Pages &gt;&gt; Choose a theme"></a>3、选择<code>hankliu62/hankliu62.github.com</code> &gt;&gt; <code>Settings</code> &gt;&gt; <code>GitHub Pages</code> &gt;&gt; <code>Choose a theme</code></h3><p><img src="https://user-images.githubusercontent.com/8088864/30236715-7a372e04-9552-11e7-8bb7-48a5d8722059.png" alt="选择主题"></p>
<p><img src="https://user-images.githubusercontent.com/8088864/30236720-9eed71d6-9552-11e7-9187-c3fac4052b28.png" alt="选择主题"></p>
<p><img src="https://user-images.githubusercontent.com/8088864/30236724-aedbb9d6-9552-11e7-9a8c-2398388b9321.png" alt="选择主题"></p>
<p>随便选择一个主题，最终会使用hexo中选择的主题样式，这里就无所谓了</p>
<h3 id="4、设置index-md-访问github博客"><a href="#4、设置index-md-访问github博客" class="headerlink" title="4、设置index.md, 访问github博客"></a>4、设置index.md, 访问github博客</h3><p><img src="https://user-images.githubusercontent.com/8088864/30236738-37332f94-9553-11e7-8714-e47de3fdecd6.png" alt="设置index.md"></p>
<h3 id="5、结合hexo，发布到github"><a href="#5、结合hexo，发布到github" class="headerlink" title="5、结合hexo，发布到github"></a>5、结合hexo，发布到github</h3><p>进入第三步创建的<code>hankliu62.github.com</code>文件夹，在<code>_config.yml</code>配置对于的github仓库, 以及本次提交的信息</p>
<pre><code class="sh">cd hankliu62.github.com

vim _config.yml
</code></pre>
<p>配置信息和提交信息如下:</p>
<pre><code class="_config.yml"># Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:
  type: git
  message: &quot;feat(blog): add hexo-github-blog-guide article&quot;
  branch: master
  repo: https://github.com/hankliu62/hankliu62.github.com.git
</code></pre>
<p>生成静态文件，再部署</p>
<pre><code class="sh">hexo g
hexo d
</code></pre>

      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
        <a data-url="http://yoursite.com/2017/09/09/hexo-github-blog-guide/" data-id="cj7cqm6th000068cg3vpkwvhv" class="article-share-link">分享到</a>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
    <article id="post-javascript-common-function" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2015/12/24/javascript-common-function/" class="article-date">
  <time datetime="2015-12-24T11:18:13.000Z" itemprop="datePublished">2015-12-24</time>
</h3>
    
  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/24/javascript-common-function/">Javascript语法糖</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <h2 id="1-Array-prototype-slice"><a href="#1-Array-prototype-slice" class="headerlink" title="1.Array.prototype.slice"></a>1.Array.prototype.slice</h2><p>数组的slice()方法通常用来从一个数组中抽取片断。但很多开发者不了解的是，这个方法还可以用来将“类数组”元素（比如 arguments、参数列表、节点列表和属性列表）转换成真正的数组：（译注：DOM 元素的属性列表通过 attributes属性获取), Array.prototype.slice.call(arguments)能将具有length属性的对象转成数组.</p>
<pre><code class="js">var a={length:2,0:&#39;first&#39;,1:&#39;second&#39;};
Array.prototype.slice.call(a);//  [&quot;first&quot;, &quot;second&quot;]

var a={length:2};
Array.prototype.slice.call(a);//  [undefined, undefined]

var argsArr = Array.prototype.slice.call(arguments);
</code></pre>
<h2 id="2-使用push来合并数组"><a href="#2-使用push来合并数组" class="headerlink" title="2.使用push来合并数组"></a>2.使用push来合并数组</h2><p>我们知道当我们想要合并两个数组时一般使用Array的concat()方法来试试，concat方法能够将两个及两个以上的数组合并成一个数组，同时我们也可以使用Array prototype 的push方法来实现两个数组的合并.</p>
<pre><code class="js">var a = [&#39;hank&#39;, &#39;mark&#39;]

var b = [&#39;hulk&#39;]

Array.prototype.push.apply(a, b)

console.log(a) // [&#39;hank&#39;, &#39;mark&#39;, &#39;hulk&#39;]
</code></pre>
<h2 id="3-Js数据去掉小数点后边的0"><a href="#3-Js数据去掉小数点后边的0" class="headerlink" title="3.Js数据去掉小数点后边的0"></a>3.Js数据去掉小数点后边的0</h2><p>在一起，我一般是使用正则表达式来替换，先判断小数点后面有无0和0的位置，然后在使用正则来替换这些0。今天突然发现一个很神奇的方法: parseFloat()</p>
<pre><code class="js">var a = 1.0;
a = parseFloat(a) // 1
</code></pre>
<p>是不是特别简单?</p>
<h2 id="4-JS浮点数运算精度"><a href="#4-JS浮点数运算精度" class="headerlink" title="4.JS浮点数运算精度"></a>4.JS浮点数运算精度</h2><p>在Javascript中两个浮点数进行运算是得到的结果可能不是我们想要的结果，比如:</p>
<pre><code class="js">var a, b;
a = 0.2;
b = 0.1;

c = a + b // 0.30000000000000004, 不是我们想要的0.3
</code></pre>
<p>主要是因为计算机是二进制浮点运算，而我们输入的是十进制浮点数，十进制数转化为二进制运算过后再转化回来，在转化过程中可能会有损失.</p>
<p>解决办法，先装换成整数，运算过后，再装换回来:</p>
<pre><code class="js">const T_NUMBER = &#39;number&#39;;
// 两数相减，其他运算同理
customSubtract = function(minuend, subtrahend) {
    var maxDecimalDigits, minuendDecimalDigits, minuendStr, result, subtrahendDecimalDigits, subtrahendStr;
    minuendStr = typeof minuend === T_NUMBER ? minuend + &#39;&#39; : minuend;
    subtrahendStr = typeof subtrahend === T_NUMBER ? subtrahend + &#39;&#39; : subtrahend;
    minuendDecimalDigits = minuendStr.indexOf(&#39;.&#39;) === -1 ? 0 : minuendStr.length - minuendStr.indexOf(&#39;.&#39;) - 1;
    subtrahendDecimalDigits = subtrahendStr.indexOf(&#39;.&#39;) === -1 ? 0 : subtrahendStr.length - subtrahendStr.indexOf(&#39;.&#39;) - 1;
    maxDecimalDigits = Math.pow(10, Math.max(minuendDecimalDigits, subtrahendDecimalDigits));
    result = (minuend * maxDecimalDigits - subtrahend * maxDecimalDigits) / maxDecimalDigits;
    return result;
};
</code></pre>
<h2 id="5-Is-object-empty"><a href="#5-Is-object-empty" class="headerlink" title="5. Is object empty?"></a>5. Is object empty?</h2><p>Check an object is empty or not?</p>
<p>Jquery has a function to check the object: <strong> jQuery.isEmptyObject </strong></p>
<pre><code class="jquery">if ($.isEmptyObject(obj)) {
  // do something
}
</code></pre>
<p>It’s easy and cross-browser function.</p>
<pre><code class="js">var isEmptyObject = function(obj) {
  for(var key in obj){
    return false; // not empty
  }

  return true; // empty
}
</code></pre>

      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

        <a data-url="http://yoursite.com/2015/12/24/javascript-common-function/" data-id="cj7cqm6tl000168cgb8vxk8ry" class="article-share-link">分享到</a>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
    <article id="post-ubuntu-netstat" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2015/12/24/ubuntu-netstat/" class="article-date">
  <time datetime="2015-12-24T10:55:37.000Z" itemprop="datePublished">2015-12-24</time>
</h3>
    
  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/24/ubuntu-netstat/">ubuntu查看和关闭端口</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <h2 id="一、查看端口"><a href="#一、查看端口" class="headerlink" title="一、查看端口"></a>一、查看端口</h2><pre><code class="shell">netstat -anp

// result
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN      -
tcp        0      0 0.0.0.0:27017           0.0.0.0:*               LISTEN      -
tcp        0      0 127.0.0.1:6379          0.0.0.0:*               LISTEN      -
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      -
tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN      -
tcp        0      0 0.0.0.0:81              0.0.0.0:*               LISTEN      -
tcp        0      0 0.0.0.0:82              0.0.0.0:*               LISTEN      -
tcp        0      0 192.168.222.198:50233   180.97.33.107:443       ESTABLISHED 2361/google-chrome-
...
Active UNIX domain sockets (servers and established)
Proto RefCnt Flags       Type       State         I-Node   PID/Program name    Path
unix  2      [ ACC ]     STREAM     LISTENING     1996     -                   /tmp/mongodb-27017.sock
unix  2      [ ACC ]     STREAM     LISTENING     781      -                   /tmp/.X11-unix/X0
unix  2      [ ACC ]     STREAM     LISTENING     12932    1799/xfce4-session  /tmp/.ICE-unix/1799
unix  2      [ ACC ]     STREAM     LISTENING     12931    1799/xfce4-session  @/tmp/.ICE-unix/1799
unix  2      [ ACC ]     STREAM     LISTENING     15489    1915/fcitx          /tmp/fcitx-socket-:0
unix  2      [ ACC ]     STREAM     LISTENING     16412    2068/sogou-qimpanel /tmp/sogou-qimpaneluser
unix  2      [ ACC ]     STREAM     LISTENING     15796    2361/google-chrome- /tmp/.com.google.Chrome.KwiQ8d/SingletonSocket
...

// 查看某个端口的进程
netstat -anp | grep 8081

// result
tcp        0      0 127.0.0.1:56770         127.0.0.1:8081          ESTABLISHED 2361/google-chrome-
tcp6       0      0 :::8081                 :::*                    LISTEN      5359/gulp
tcp6       0      0 127.0.0.1:8081          127.0.0.1:56770         ESTABLISHED 5359/gulp
</code></pre>
<h2 id="二、关闭某个端口的进程"><a href="#二、关闭某个端口的进程" class="headerlink" title="二、关闭某个端口的进程"></a>二、关闭某个端口的进程</h2><pre><code class="shell">kill -9 5359
</code></pre>

      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PID/">PID</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ubuntu/">ubuntu</a></li></ul>

        <a data-url="http://yoursite.com/2015/12/24/ubuntu-netstat/" data-id="cj7cqm6tn000268cgu7gtli2d" class="article-share-link">分享到</a>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
    <article id="post-javascript-module" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2015/12/24/javascript-module/" class="article-date">
  <time datetime="2015-12-24T10:55:37.000Z" itemprop="datePublished">2015-12-24</time>
</h3>
    
  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/24/javascript-module/">菜鸟学习Javascript模块化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <h2 id="一、模块化的定义"><a href="#一、模块化的定义" class="headerlink" title="一、模块化的定义"></a>一、模块化的定义</h2><p>模块化是一种处理复杂系统分解为更好的可管理模块的方式。它可以通过在不同组件设定不同的功能，把一个问题分解成多个小的独立、互相作用的组件，来处理复杂、大型的软件。简单点来讲就是以功能为单位，然后通过不同功能的组合来实现一个系统，模块化的主要的目的就是为了减少依赖，减少耦合，提交代码的复用性，最终提交开发的效率。为了这个目的，所以我们必须将耦合密度的功能定义在一个模块中，并且在每个模块中第一一些入口和出口，以方便模块的组合和交互。</p>
<h2 id="二、Javascript的模块化"><a href="#二、Javascript的模块化" class="headerlink" title="二、Javascript的模块化"></a>二、Javascript的模块化</h2><p>随着网站逐渐变成”互联网应用程序”，嵌入网页的Javascript代码越来越庞大，越来越复杂。Javascript模块化编程，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。</p>
<h2 id="三、Javascript模块化的发展"><a href="#三、Javascript模块化的发展" class="headerlink" title="三、Javascript模块化的发展"></a>三、Javascript模块化的发展</h2><h3 id="1、原始写法"><a href="#1、原始写法" class="headerlink" title="1、原始写法"></a>1、原始写法</h3><p>模块就是实现特定功能的一组方法。,不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。</p>
<pre><code class="js">function m1(){
　　//...
}
function m2(){
　　//...
}
</code></pre>
<p>缺点：”污染”了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。</p>
<h3 id="2、对象写法"><a href="#2、对象写法" class="headerlink" title="2、对象写法"></a>2、对象写法</h3><p>为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面。使用的时候，就是调用这个对象的属性。</p>
<pre><code class="js">var module1 = new Object({
　　_count : 0,
　　m1 : function (){
　　　 //...
　　},
　　m2 : function (){
　　　　//...
　　}
});
</code></pre>
<p>缺点：写法会暴露所有模块成员，内部状态可以被外部改写</p>
<h3 id="3、立即执行函数写法"><a href="#3、立即执行函数写法" class="headerlink" title="3、立即执行函数写法"></a>3、立即执行函数写法</h3><p>使用”立即执行函数”，可以达到不暴露私有成员的目的。</p>
<pre><code class="js">var module1 = (function(){
　　var _count = 0;
　　var m1 = function(){
　　　　//...
　　};
　　var m2 = function(){
　　　　//...
　　};
　　return {
　　　　m1 : m1,
　　　　m2 : m2
　　};
})();
</code></pre>
<p>module1就是Javascript模块的基本写法。下面，再对这种写法进行加工。</p>
<h3 id="4、放大模式"><a href="#4、放大模式" class="headerlink" title="4、放大模式"></a>4、放大模式</h3><p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用”放大模式”。</p>
<pre><code class="js">var module1 = (function (mod){
　　mod.m3 = function () {
　　　　//...
　　};
　　return mod;
})(module1);
</code></pre>
<p>上面的代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。</p>
<h3 id="5、宽放大模式"><a href="#5、宽放大模式" class="headerlink" title="5、宽放大模式"></a>5、宽放大模式</h3><p>在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上一节的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”。</p>
<pre><code class="js">var module1 = ( function (mod){
　　//...
　　return mod;
})(window.module1 || {});
</code></pre>
<p>与”放大模式”相比，＂宽放大模式＂就是”立即执行函数”的参数可以是空对象。</p>
<h3 id="6、输入全局变量"><a href="#6、输入全局变量" class="headerlink" title="6、输入全局变量"></a>6、输入全局变量</h3><p>独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。<br>为了在模块内部调用全局变量，必须显式地将其他变量输入模块。</p>
<pre><code class="js">var module1 = (function ($, YAHOO) {
　　//...
})(jQuery, YAHOO);
</code></pre>
<p>上面的module1模块需要使用jQuery库和YUI库，就把这两个库（其实是两个模块）当作参数输入module1。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。</p>
<h2 id="四、模块的规范"><a href="#四、模块的规范" class="headerlink" title="四、模块的规范"></a>四、模块的规范</h2><p>先想一想，为什么模块很重要？<br>因为有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。<br>但是，这样做有一个前提，那就是大家必须以同样的方式编写模块，否则你有你的写法，我有我的写法，岂不是乱了套！考虑到Javascript模块现在还没有官方规范，这一点就更重要了。<br>目前，通行的Javascript模块规范共有两种：CommonJS和AMD。我主要介绍AMD，但是要先从CommonJS讲起。</p>
<h3 id="1、CommonJS"><a href="#1、CommonJS" class="headerlink" title="1、CommonJS"></a>1、CommonJS</h3><p>2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程。</p>
<p>这标志”Javascript模块化编程”正式诞生。因为老实说，在浏览器环境下，没有模块也不是特别大的问题，毕竟网页程序的复杂性有限；但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。<br>node.js的模块系统，就是参照CommonJS规范实现的。在CommonJS中，有一个全局性方法require()，用于加载模块。假定有一个数学模块math.js，就可以像下面这样加载。</p>
<pre><code class="js">var math = require(&#39;math&#39;);
</code></pre>
<p>然后，就可以调用模块提供的方法：</p>
<pre><code class="js">var math = require(&#39;math&#39;);
math.add(2,3); // 5
</code></pre>
<h3 id="2、浏览器环境"><a href="#2、浏览器环境" class="headerlink" title="2、浏览器环境"></a>2、浏览器环境</h3><p>有了服务器端模块以后，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。<br>但是，由于一个重大的局限，使得CommonJS规范不适用于浏览器环境。还是上一节的代码，如果在浏览器中运行，会有一个很大的问题，你能看出来吗？</p>
<pre><code class="js">var math = require(&#39;math&#39;);
math.add(2, 3);
</code></pre>
<p>第二行math.add(2, 3)，在第一行require(‘math’)之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。<br>这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。<br>因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。</p>
<h3 id="3、AMD"><a href="#3、AMD" class="headerlink" title="3、AMD"></a>3、AMD</h3><p>AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。<br>AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：</p>
<pre><code class="js">require([module], callback);
</code></pre>
<p>第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成AMD形式，就是下面这样：</p>
<pre><code class="js">require([&#39;math&#39;], function (math) {
　　math.add(2, 3);
});
</code></pre>
<p>math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。<br>目前，主要有两个Javascript库实现了AMD规范：require.js和curl.js。</p>
<h2 id="五、require-js"><a href="#五、require-js" class="headerlink" title="五、require.js"></a>五、require.js</h2><h3 id="1、为什么要用require-js"><a href="#1、为什么要用require-js" class="headerlink" title="1、为什么要用require.js"></a>1、为什么要用require.js</h3><p>最早的时候，所有Javascript代码都写在一个文件里面，只要加载这一个文件就够了。后来，代码越来越多，一个文件不够了，必须分成多个文件，依次加载。下面的网页代码，相信很多人都见过。</p>
<pre><code class="js">&lt;script src=&quot;1.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;2.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;3.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;4.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;5.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;6.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>这段代码依次加载多个js文件。<br>这样的写法有很大的缺点。首先，加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长；其次，由于js文件之间存在依赖关系，因此必须严格保证加载顺序（比如上例的1.js要在2.js的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。<br>require.js的诞生，就是为了解决这两个问题：</p>
<ul>
<li>实现js文件的异步加载，避免网页失去响应</li>
<li>管理模块之间的依赖性，便于代码的编写和维护</li>
</ul>
<h3 id="2、require-js的加载"><a href="#2、require-js的加载" class="headerlink" title="2、require.js的加载"></a>2、require.js的加载</h3><p>使用require.js的第一步，是先去官方网站下载最新版本。<br>下载后，假定把它放在js子目录下面，就可以加载了。</p>
<pre><code class="js">&lt;script src=&quot;js/require.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>加载这个文件，也可能造成网页失去响应。解决办法有两个，一个是把它放在网页底部加载，另一个是写成下面这样：</p>
<pre><code class="js">&lt;script src=&quot;js/require.js&quot; defer async=&quot;true&quot;&gt;&lt;/script&gt;
</code></pre>
<p>async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上。<br>加载require.js以后，下一步就要加载我们自己的代码了。假定我们自己的代码文件是main.js，也放在js目录下面。那么，只需要写成下面这样就行了：</p>
<pre><code class="js">&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot; defer async=&quot;true&quot;&gt;&lt;/script&gt;
</code></pre>
<p>data-main属性的作用是，指定网页程序的主模块。在上例中，就是js目录下面的main.js，这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。</p>
<h3 id="3、主模块的写法"><a href="#3、主模块的写法" class="headerlink" title="3、主模块的写法"></a>3、主模块的写法</h3><p>上一节的main.js，我把它称为”主模块”，意思是整个网页的入口代码。它有点像C语言的main()函数，所有代码都从这儿开始运行。<br>下面就来看，怎么写main.js。<br>如果我们的代码不依赖任何其他模块，那么可以直接写入javascript代码。</p>
<pre><code class="js">// main.js
alert(&quot;加载成功！&quot;);
</code></pre>
<p>但这样的话，就没必要使用require.js了。真正常见的情况是，主模块依赖于其他模块，这时就要使用AMD规范定义的的require()函数。</p>
<pre><code class="js">// main.js
require([&#39;moduleA&#39;, &#39;moduleB&#39;, &#39;moduleC&#39;], function (moduleA, moduleB, moduleC){
　　// some code here
});
</code></pre>
<p>require()函数接受两个参数。第一个参数是一个数组，表示所依赖的模块，上例就是[‘moduleA’, ‘moduleB’, ‘moduleC’]，即主模块依赖这三个模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。<br>require()异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。<br>下面，我们看一个实际的例子。<br>假定主模块依赖jquery、underscore和backbone这三个模块，main.js就可以这样写：</p>
<pre><code class="js">require([&#39;jquery&#39;, &#39;underscore&#39;, &#39;backbone&#39;], function ($, _, Backbone){
　　// some code here
});
</code></pre>
<p>require.js会先加载jQuery、underscore和backbone，然后再运行回调函数。主模块的代码就写在回调函数中。</p>
<h3 id="4、模块的加载"><a href="#4、模块的加载" class="headerlink" title="4、模块的加载"></a>4、模块的加载</h3><p>上一节最后的示例中，主模块的依赖模块是[‘jquery’, ‘underscore’, ‘backbone’]。默认情况下，require.js假定这三个模块与main.js在同一个目录，文件名分别为jquery.js，underscore.js和backbone.js，然后自动加载。<br>使用require.config()方法，我们可以对模块的加载行为进行自定义。require.config()就写在主模块（main.js）的头部。参数就是一个对象，这个对象的paths属性指定各个模块的加载路径。</p>
<pre><code class="js">require.config({
　 paths: {
　　　　&quot;jquery&quot;: &quot;jquery.min&quot;,
　　　　&quot;underscore&quot;: &quot;underscore.min&quot;,
　　　　&quot;backbone&quot;: &quot;backbone.min&quot;
　　}
});
</code></pre>
<p>上面的代码给出了三个模块的文件名，路径默认与main.js在同一个目录（js子目录）。如果这些模块在其他目录，比如js/lib目录，则有两种写法。一种是逐一指定路径。</p>
<pre><code class="js">require.config({
　　paths: {
　　　　&quot;jquery&quot;: &quot;lib/jquery.min&quot;,
　　　　&quot;underscore&quot;: &quot;lib/underscore.min&quot;,
　　　　&quot;backbone&quot;: &quot;lib/backbone.min&quot;
　　}
});
</code></pre>
<p>另一种则是直接改变基目录（baseUrl）。</p>
<pre><code class="js">require.config({
　　baseUrl: &quot;js/lib&quot;,
　　paths: {
　　　　&quot;jquery&quot;: &quot;jquery.min&quot;,
　　　　&quot;underscore&quot;: &quot;underscore.min&quot;,
　　　　&quot;backbone&quot;: &quot;backbone.min&quot;
　　}
});
</code></pre>
<p>require.js要求，每个模块是一个单独的js文件。这样的话，如果加载多个模块，就会发出多次HTTP请求，会影响网页的加载速度。因此，require.js提供了一个优化工具，当模块部署完毕以后，可以用这个工具将多个模块合并在一个文件中，减少HTTP请求数。</p>
<h3 id="5、AMD模块的写法"><a href="#5、AMD模块的写法" class="headerlink" title="5、AMD模块的写法"></a>5、AMD模块的写法</h3><p>require.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写。<br>具体来说，就是模块必须采用特定的define()函数来定义。如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。<br>假定现在有一个math.js文件，它定义了一个math模块。那么，math.js就要这样写：</p>
<pre><code class="js">// math.js
define(function (){
　　var add = function (x,y){
　　　　return x+y;
　　};
　　return {
　　　　add: add
　　};
});

// 加载方式
require([&#39;math&#39;], function (math){
　　alert(math.add(1,1));
});
</code></pre>
<p>如果这个模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。</p>
<pre><code class="js">define([&#39;myLib&#39;], function(myLib){
　　function foo(){
　　　　myLib.doSomething();
　　}
　　return {
　　　　foo : foo
　　};
});
</code></pre>
<p>当require()函数加载上面这个模块的时候，就会先加载myLib.js文件。</p>
<h3 id="6、加载非规范的模块"><a href="#6、加载非规范的模块" class="headerlink" title="6、加载非规范的模块"></a>6、加载非规范的模块</h3><p>理论上，require.js加载的模块，必须是按照AMD规范、用define()函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合。那么，require.js是否能够加载非规范的模块呢？<br>回答是可以的。<br>这样的模块在用require()加载之前，要先用require.config()方法，定义它们的一些特征。<br>举例来说，underscore和backbone这两个库，都没有采用AMD规范编写。如果要加载它们的话，必须先定义它们的特征。</p>
<pre><code class="js">require.config({
　　shim: {
　　　　&#39;underscore&#39;:{
　　　　　　exports: &#39;_&#39;
　　　　},
　　　　&#39;backbone&#39;: {
　　　　　　deps: [&#39;underscore&#39;, &#39;jquery&#39;],
　　　　　　exports: &#39;Backbone&#39;
　　　　}
　　}
});
</code></pre>
<p>require.config()接受一个配置对象，这个对象除了有前面说过的paths属性之外，还有一个shim属性，专门用来配置不兼容的模块。具体来说，每个模块要定义（1）exports值（输出的变量名），表明这个模块外部调用时的名称；（2）deps数组，表明该模块的依赖性。<br>比如，jQuery的插件可以这样定义：</p>
<pre><code class="js">shim: {
　　&#39;jquery.scroll&#39;: {
　　　　deps: [&#39;jquery&#39;],
　　　　exports: &#39;jQuery.fn.scroll&#39;
　　}
}
</code></pre>
<h3 id="7、require-js插件"><a href="#7、require-js插件" class="headerlink" title="7、require.js插件"></a>7、require.js插件</h3><p>require.js还提供一系列插件，实现一些特定的功能。</p>
<pre><code class="js">// domready插件，可以让回调函数在页面DOM结构加载完成后再运行。
require([&#39;domready!&#39;], function (doc){
　　// called once the DOM is ready
});

// text和image插件，则是允许require.js加载文本和图片文件。
define([&#39;text!review.txt&#39;, &#39;image!cat.jpg&#39;], function(review,cat){
　　console.log(review);
　　document.body.appendChild(cat);
});

//类似的插件还有json和mdown，用于加载json文件和markdown文件。
</code></pre>
<h2 id="六、自己的看法"><a href="#六、自己的看法" class="headerlink" title="六、自己的看法"></a>六、自己的看法</h2><p>&ensp;&ensp;&ensp;&ensp;作为一个前端模块化的菜鸟，看了上面对Javascript模块化的定义，发展以及规范的一些描述，使我对JavaScript模块化有了一定的了解，RequireJS 是一个很优秀的模块加载器，让JavaScript的模块化开发更加简洁，定义了一个作用域来避免全局名称空间污染，并且通过RequireJs的语法，使得模块与模块之间的依赖关系非常明显，同时，它提倡提前执行依赖，通过模块的异步加载，加快了模块的加载速度，虽然异步加载的顺序可能不一定的，通过依赖关系来加载的模块是可确定的，提前执行依赖，有好处也有坏处，好处就是具有良好的用户体检，在一开始加载完依赖后，无需再加载依赖，用户操作的反应速度也会更快，但是坏处就是肯能会存在带宽的浪费，因为提前加载依赖可能在之后的代码运行中不一定会用到。个人觉得有时候为了更好的用户体验，一定的带宽的浪费是可取的。RequireJS特别突出的优点就是，它有着详细文档，丰富案例和活跃的社区论坛，而且使用RequireJS的前端大牛也非常多，当我们存在任何疑问的时候，我们可以通过文档或者咨询前端大牛得到帮助。RequireJS的优势在于异步加载，加快模块加载速度，同时它的坑爹之处也在于它的异步加载，异步加载会导致模块加载顺序不是确定的，如果开发者不注意的话，会造成一些意想不到的结果。</p>
<p>&ensp;&ensp;&ensp;&ensp;聊完了RequireJS，我们再来聊一聊另一种规范的模块加载器：SeaJS，SeaJS 是遵循的 CMD （通用模块定义）规范的模块加载器，CMD规范明确的给定了基本的写法和交互规则，还规定了每一个模块都是一个文件，具体模块的都是使用define关键字来定义的，并且使用exports（对象）用来向外提供模块接口，同时通过require关键字来获取其他模块提供的接口，由此可以看出，CMD规范与Node.js的Modules规范非常相似。SeaJs就是CMD规范的一个明显的代表，通用API只有define, require, require.async, exports, module.exports这五个，所以学习起来非常的快速和方便。SeaJs的代码书写非常简单，SeaJs推崇的是依赖靠近的原则，所以其依赖关系清晰明了，能够提高JavaScript代码的可读性，这是与RequireJS一个很明显的不同点，RequireJS推崇的是依赖前置，RequireJS将模块依赖的关系定义在模块的头部，另一个不同的地方在于，RequireJS对于依赖的模块是提前执行的（RequireJS 2.0后，提供了延迟执行的写法），而SeaJs延迟执行的，SeaJs提倡的是as lazy as possible。提前执行有好处也有坏处，在上面也提到过，所以提前执行的优点还是要看具体运行的环境的。</p>
<p>&ensp;&ensp;&ensp;&ensp;2015年6月17日，ECMAScript 6发布正式版本，ES6在ES5的基础上做了很大的改动，好像听到了前端开发人员对Javascript模块化的强烈呼唤，所以ES6增添了许多必要的特性，比如说：模块和类，由于以前JavaScript没有内置方法来支持模块化，开发者使用模块化的方式并不统一，所以ES6模块化的目标是创建一种 CommonJS 和 AMD 使用者都乐意接受的方式，语法与CommonJS类似，简洁明了，倾向于单一的接口，同时也类似AMD，支持模块的异步加载和配置模块加载，我觉得ES6的好处就是，首先，不需要任何的第三方库可以实现JavaScript的模块化，节约带宽和内存，其次，就是其语法非常简单，一般来说，我们使用export关键词导出对象，这个关键字可以无限次使用；使用import关键字将其它模块导入某一模块中，它可用来导入任意数量的模块。一般情况下，只需要上述两个关键字就实现了模块化。总的来说使用ES6来实现模块化相对于上述两种方案更加方便简洁，我们就静静的等待浏览器对ES6的支持吧，到时候ES6一定会大放光彩。</p>
<p>文章出处：<a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2012/10/javascript_module.html</a></p>

      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javascript/">Javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/模块化/">模块化</a></li></ul>

        <a data-url="http://yoursite.com/2015/12/24/javascript-module/" data-id="cj7cqm6tp000468cgj8ptwztf" class="article-share-link">分享到</a>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
  
</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/09/09/hexo-github-blog-guide/">MAC搭建个人博客hexo+github详细完整步骤</a>
          </li>
        
          <li>
            <a href="/2015/12/24/javascript-common-function/">Javascript语法糖</a>
          </li>
        
          <li>
            <a href="/2015/12/24/ubuntu-netstat/">ubuntu查看和关闭端口</a>
          </li>
        
          <li>
            <a href="/2015/12/24/javascript-module/">菜鸟学习Javascript模块化</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/">Javascript</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PID/">PID</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ubuntu/">ubuntu</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模块化/">模块化</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 hankliu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/sun11/hexo-theme-paperbox" target="_blank">Paperbox</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
  <a href="#search" class="mobile-nav-link st-search-show-outputs">Search</a>
</nav>
  

<!-- totop start -->
<div id="totop">
	<a title="返回顶部"></a>
</div>
<!-- totop end -->

<!-- swiftype search start -->

<!-- swiftype search end -->



<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/lrsjng.jquery-qrcode/0.12.0/jquery.qrcode.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

</div>
</body>
</html>
