
<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  
  <title>HankLiu的博客小屋</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="努力去听风的声音，不必在意风的方向。">
<meta property="og:type" content="website">
<meta property="og:title" content="HankLiu的博客小屋">
<meta property="og:url" content="https://hankliu62.github.io/index.html">
<meta property="og:site_name" content="HankLiu的博客小屋">
<meta property="og:description" content="努力去听风的声音，不必在意风的方向。">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HankLiu的博客小屋">
<meta name="twitter:description" content="努力去听风的声音，不必在意风的方向。">
  
  
    <link rel="icon" href="/img/favicon.ico" sizes="16x16">
  
  <link rel="stylesheet" href="/css/style.css?t=1">
  
    <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
  

</head>
</html>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner">
    <div id="banner-mask"></div>
  </div>
  <div id="header-outer" class="outer">
    <nav id="upper-nav" class="inner">
      <a id="main-nav-toggle" class="nav-icon"></a>
      <div class="sub-nav">
        
        
          <a id="nav-github" class="nav-icon" href="https://github.com/hankliu62"></a>
        
      </div>
    </nav>
    <div id="header-title">
      
        <h1 id="blog-title-wrap">
          <a href="/" id="blog-title">HankLiu的博客小屋</a>
        </h1>
      
      
        <h5 class="blog-subtitle-wrap">努力去听风的声音，不必在意风的方向。</h5>
      
    </div>
    <div id="contenedor">
      <ul class="cube">
        <li class="cara"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="100" width="100" viewBox="-50 -50 200 200">
          <circle cx="50" cy="50" r="45" stroke-width="5" stroke="black" stroke-opacity="0.5" fill-opacity="0"></circle>
          <rect id="clockwise" x="47.5" y="27.5" width="5" height="25" rx="2.5" ry="2.5" fill="black" fill-opacity="0.5" transform="rotate(330 50 50)"></rect>
          <rect id="minute" x="48.5" y="16.5" width="3" height="35" rx="1.5" ry="1.5" fill="black" fill-opacity="0.5"></rect>
        </svg></li>
        <li class="cara">P</li>
        <li class="cara">X</li>
        <li class="cara">L</li>
        <li class="cara">C</li>
        <li class="cara">Y</li>
      </ul>
    </div>
    <nav id="main-nav">
      
        <a class="main-nav-link" href="/">主页</a>
      
        <a class="main-nav-link" href="/archives">文章</a>
      
        <a class="main-nav-link" href="/toolbox-frontend">小工具</a>
      
        <a class="main-nav-link" href="/resume">小简介</a>
      
    </nav>
  </div>
</header>

    <div class="outer">
      <section id="main">
  
    <article id="post-security-anti-reptile" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2024/04/02/security-anti-reptile/" class="article-date">
  <time datetime="2024-04-02T02:40:20.000Z" itemprop="datePublished">2024-04-02</time>
</h3>
    
  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content fill-content-true">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/04/02/security-anti-reptile/">Web安全之静态内容防爬虫</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <h2 id="Web安全之静态内容防爬虫"><a href="#Web安全之静态内容防爬虫" class="headerlink" title="Web安全之静态内容防爬虫"></a>Web安全之静态内容防爬虫</h2><p>随着互联网的快速发展，网络安全问题日益突出。对于静态内容网站来说，防止恶意爬取网站内容成为了一项重要的任务。恶意爬取不仅会导致网站内容被盗用，还可能引发一系列安全问题，如数据泄露、恶意攻击等。因此，本文将探讨静态内容网站如何防范恶意爬取，提高网络安全。</p>
<h3 id="静态内容网站的特点"><a href="#静态内容网站的特点" class="headerlink" title="静态内容网站的特点"></a>静态内容网站的特点</h3><p>静态内容网站主要是指那些网页内容固定不变或变化较少的网站。这类网站通常以 <code>HTML</code> 、 <code>CSS</code> 和 <code>JavaScript</code> 等静态文件形式存在，不依赖后端数据库或复杂的应用程序。由于其结构简单、加载速度快，静态网站在新闻发布、产品展示、个人博客等领域得到广泛应用。</p>
<h3 id="恶意爬取的威胁"><a href="#恶意爬取的威胁" class="headerlink" title="恶意爬取的威胁"></a>恶意爬取的威胁</h3><p>恶意爬取是指未经授权，通过自动化手段（如爬虫程序）大规模抓取网站内容的行为。这种行为通常具有以下特点：</p>
<ol>
<li><strong>大规模：</strong>恶意爬取往往涉及大量的请求，给服务器带来沉重负担。</li>
<li><strong>未经授权：</strong>爬取行为未经网站所有者许可，违反了版权和隐私政策。</li>
<li><strong>恶意目的：</strong>恶意爬取可能导致内容被盗用、数据泄露、恶意攻击等后果。</li>
</ol>
<h3 id="防恶意爬取策略"><a href="#防恶意爬取策略" class="headerlink" title="防恶意爬取策略"></a>防恶意爬取策略</h3><p>为了防范恶意爬取，静态内容网站可以采取以下措施：</p>
<h4 id="设置robots-txt文件"><a href="#设置robots-txt文件" class="headerlink" title="设置robots.txt文件"></a>设置robots.txt文件</h4><p><code>robots.txt</code> 文件是一个用于告知搜索引擎爬虫哪些页面可以爬取、哪些页面不能爬取的文本文件。通过设置 <code>robots.txt</code> 文件，可以限制恶意爬虫的访问。</p>
<p>下面是一个 robots.txt 文件的例子，展示了如何设置一些基本的规则。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Disallow: /</span><br><span class="line"></span><br><span class="line"># 禁止所有爬虫访问网站的所有页面</span><br><span class="line"></span><br><span class="line">User-agent: Googlebot</span><br><span class="line">Disallow:</span><br><span class="line"></span><br><span class="line"># 允许 Googlebot 访问网站的所有页面</span><br><span class="line"></span><br><span class="line">User-agent: Bingbot</span><br><span class="line">Disallow: /private/</span><br><span class="line"></span><br><span class="line"># 禁止 Bingbot 访问 /private/ 目录下的所有页面</span><br><span class="line"></span><br><span class="line">User-agent: Yahoo! Slurp</span><br><span class="line">Disallow: /admin/</span><br><span class="line"></span><br><span class="line"># 禁止 Yahoo! Slurp 访问 /admin/ 目录下的所有页面</span><br><span class="line"></span><br><span class="line">User-agent: *</span><br><span class="line">Disallow: /cgi-bin/</span><br><span class="line"></span><br><span class="line"># 禁止所有其他爬虫访问 /cgi-bin/ 目录下的所有页面</span><br><span class="line"></span><br><span class="line"># 允许特定爬虫访问特定页面</span><br><span class="line">User-agent: SpecificBot</span><br><span class="line">Allow: /special-page/</span><br><span class="line">Disallow: /</span><br><span class="line"></span><br><span class="line"># 对于名为 SpecificBot 的爬虫，只允许访问 /special-page/ 页面，其他页面都不允许访问</span><br></pre></td></tr></table></figure>
<p>在上面的例子中：</p>
<ul>
<li><strong>User-agent: *</strong> 表示该规则适用于所有爬虫。</li>
<li><strong>Disallow: /</strong> 表示禁止爬虫访问网站的根目录及其所有子目录和文件。</li>
<li><strong>Allow: /special-page/</strong> 表示允许特定爬虫访问 <code>/special-page/</code> 页面。<code>Allow</code> 指令必须在 <code>Disallow</code> 指令之前，否则将无效。</li>
<li><strong>User-agent: SpecificBot</strong> 表示该规则仅适用于名为 <code>SpecificBot</code> 的爬虫。</li>
</ul>
<p>请注意， <code>robots.txt</code> 文件必须放置在网站的根目录下（通常是 <code>http://www.example.com/robots.txt</code>），以便爬虫能够找到它。同时，虽然大多数负责任的爬虫都会遵守 <code>robots.txt</code> 的规则，但并非所有爬虫都会遵守，因此它不能作为一种安全机制来防止数据被爬取。</p>
<h4 id="使用验证码技术"><a href="#使用验证码技术" class="headerlink" title="使用验证码技术"></a>使用验证码技术</h4><p>对于关键页面或敏感内容，可以引入验证码技术。用户在访问这些页面时需要输入正确的验证码才能继续浏览，从而有效阻止恶意爬虫的访问。</p>
<p>验证码技术的案例有很多，以下列举几个常见的案例：</p>
<ol>
<li><strong>网站注册和登录验证码：</strong>这是最常见的验证码技术案例。用户在注册或登录网站时，系统会显示一组随机生成的字符或图片，并要求用户输入或选择正确的字符或图片来完成验证。这种技术可以有效防止自动化程序恶意攻击网站，如进行暴力破解密码、刷票等行为。</li>
<li><strong>图片验证码：</strong>图片验证码是一种将随机生成的字符或数字嵌入到图片中，并要求用户识别并输入正确字符或数字的验证码技术。这种技术可以有效防止自动化程序识别并输入验证码，提高网站的安全性。</li>
<li><strong>滑动验证码：</strong>滑动验证码是一种要求用户通过滑动解锁来完成验证的技术。用户需要按照指定的方向或轨迹滑动滑块，才能完成验证。这种技术可以有效防止自动化程序模拟用户操作，提高网站的安全性。</li>
<li><strong>音频验证码：</strong>音频验证码是一种将随机生成的字符或数字转换为语音，并要求用户听取并输入正确字符或数字的验证码技术。这种技术适用于视觉障碍用户或无法通过图片验证码验证的情况。</li>
<li><strong>逻辑验证码：</strong>逻辑验证码是一种要求用户解决一个简单数学问题或逻辑问题来完成验证的技术。例如，系统可能会显示一个加法或减法问题，并要求用户输入正确答案。这种技术可以有效防止自动化程序识别并输入验证码，提高网站的安全性。</li>
</ol>
<h4 id="限制访问频率"><a href="#限制访问频率" class="headerlink" title="限制访问频率"></a>限制访问频率</h4><p>通过设置合理的访问频率限制，可以防止恶意爬虫大量请求服务器资源。例如，可以设置每个IP地址在单位时间内的最大请求次数。</p>
<p>限制访问频率的 <code>Node.js</code> 例子可以使用 <code>Redis</code> 来实现。下面是一个简单的示例代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Redis = <span class="built_in">require</span>(<span class="string">'ioredis'</span>);</span><br><span class="line"><span class="keyword">const</span> redis = <span class="keyword">new</span> Redis(&#123;</span><br><span class="line">  port: <span class="number">6379</span>, <span class="comment">// Redis 端口</span></span><br><span class="line">  host: <span class="string">'localhost'</span>, <span class="comment">// Redis 主机地址</span></span><br><span class="line">  password: <span class="string">'your_redis_password'</span>, <span class="comment">// Redis 密码</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ACCESS_FREQUENCY = <span class="number">5</span>; <span class="comment">// 设定访问频率限制，例如每分钟最多访问 5 次</span></span><br><span class="line"><span class="keyword">const</span> EXPIRE_TIME = <span class="number">60</span>; <span class="comment">// 设定过期时间，例如每分钟过期</span></span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/protected-route'</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> ip = req.ip; <span class="comment">// 获取请求 IP</span></span><br><span class="line">  <span class="keyword">const</span> key = <span class="string">`access-frequency:<span class="subst">$&#123;ip&#125;</span>`</span>; <span class="comment">// 构建 Redis 键名</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="keyword">await</span> redis.get(key); <span class="comment">// 获取当前 IP 的访问次数</span></span><br><span class="line">    <span class="keyword">if</span> (count &amp;&amp; <span class="built_in">parseInt</span>(count) &gt;= ACCESS_FREQUENCY) &#123;</span><br><span class="line">      <span class="keyword">return</span> res.status(<span class="number">429</span>).send(<span class="string">'Too Many Requests'</span>); <span class="comment">// 超过访问频率限制，返回 429 状态码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> newCount = count ? <span class="built_in">parseInt</span>(count) + <span class="number">1</span> : <span class="number">1</span>; <span class="comment">// 更新访问次数</span></span><br><span class="line">    <span class="keyword">await</span> redis.set(key, newCount, <span class="string">'EX'</span>, EXPIRE_TIME); <span class="comment">// 设置新的访问次数，并设置过期时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理正常请求逻辑...</span></span><br><span class="line">    res.send(<span class="string">'Success'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'Error:'</span>, error);</span><br><span class="line">    res.status(<span class="number">500</span>).send(<span class="string">'Internal Server Error'</span>); <span class="comment">// 发生错误时返回 500 状态码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们使用 <code>Redis</code> 来存储每个 <code>IP</code> 的访问次数，并设定了一个访问频率限制（例如每分钟最多访问 <code>5</code> 次）。当一个请求到达时，我们首先获取当前 <code>IP</code> 的访问次数，如果超过了限制，则返回 <code>429</code> 状态码表示请求过多。否则，我们更新访问次数，并设置过期时间，以便在下一分钟内重置访问次数。最后，我们处理正常的请求逻辑并返回成功响应。</p>
<p>请注意，这只是一个简单的示例代码，实际应用中可能需要更多的逻辑和安全性考虑，例如使用分布式锁来防止并发访问问题，以及使用更复杂的算法来计算访问频率等。</p>
<h4 id="数据混淆"><a href="#数据混淆" class="headerlink" title="数据混淆"></a>数据混淆</h4><p>数据混淆是指通过改变数据的表示方式或结构，使得爬虫无法直接解析出真实数据的方法。</p>
<p>假设你有一个包含敏感信息的API接口，返回的数据是JSON格式的。为了防止爬虫直接获取到这些数据，你可以对返回的数据进行混淆处理。</p>
<p>原始数据:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"张三"</span>,</span><br><span class="line">    <span class="attr">"age"</span>: <span class="number">30</span>,</span><br><span class="line">    <span class="attr">"email"</span>: <span class="string">"zhangsan@example.com"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>混淆后的数据:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"n1"</span>: <span class="string">"Z3Nj"</span>,</span><br><span class="line">    <span class="attr">"a2"</span>: <span class="string">"MzAi"</span>,</span><br><span class="line">    <span class="attr">"e3"</span>: <span class="string">"emFuc2FuQGV4YW1wbGUuY29t"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，你可以使用一种简单的混淆算法（如Base64编码）对原始数据进行编码，然后在前端使用相应的解码算法进行解码，以显示真实的数据。这样，爬虫获取到的只是混淆后的数据，无法直接解析出真实的信息。</p>
<h4 id="加密传输"><a href="#加密传输" class="headerlink" title="加密传输"></a>加密传输</h4><p>使用HTTPS协议对网站内容进行加密传输，可以防止恶意爬虫在传输过程中窃取数据。此外，HTTPS协议还能提高网站的安全性，保护用户隐私。</p>
<h4 id="使用反爬虫技术"><a href="#使用反爬虫技术" class="headerlink" title="使用反爬虫技术"></a>使用反爬虫技术</h4><p>反爬虫技术是一种主动防御手段，通过识别并阻止恶意爬虫的访问。例如，可以通过分析请求头、请求频率、用户代理等信息来判断是否为恶意爬虫，并采取相应的防御措施。</p>
<p>下面是一个简单的 <code>express</code> 示例代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> rateLimit = <span class="built_in">require</span>(<span class="string">'express-rate-limit'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置访问频率限制</span></span><br><span class="line"><span class="keyword">const</span> limiter = rateLimit(&#123;</span><br><span class="line">    windowMs: <span class="number">15</span> * <span class="number">60</span> * <span class="number">1000</span>, <span class="comment">// 15分钟</span></span><br><span class="line">    max: <span class="number">100</span>, <span class="comment">// 在时间窗口内的最大请求数</span></span><br><span class="line">    message: <span class="string">'Too many requests from this IP, please try again later.'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/protected-route'</span>, limiter);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/protected-route'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> userAgent = req.headers[<span class="string">'user-agent'</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查User-Agent是否像是浏览器的</span></span><br><span class="line">    <span class="keyword">if</span> (!userAgent || !userAgent.includes(<span class="string">'Mozilla'</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> res.status(<span class="number">403</span>).send(<span class="string">'Forbidden'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设这是从数据库或API获取敏感数据的函数</span></span><br><span class="line">    fetchSensitiveData().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        res.send(data);</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">        res.status(<span class="number">500</span>).send(<span class="string">'Internal Server Error'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Server is running on port 3000'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchSensitiveData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里模拟从数据库或API获取数据的过程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(&#123; <span class="attr">sensitiveInformation</span>: <span class="string">'This is sensitive data'</span> &#125;);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们使用了 <code>express-rate-limit</code> 中间件来限制来自同一 <code>IP</code> 的请求频率，并检查了 <code>User-Agent</code> 头来识别非浏览器请求。</p>
<h4 id="定期更新内容"><a href="#定期更新内容" class="headerlink" title="定期更新内容"></a>定期更新内容</h4><p>定期更新网站内容可以降低恶意爬虫的兴趣。同时，通过不断更新网站结构和内容，可以增加恶意爬虫爬取的难度。</p>
<h4 id="建立安全监测机制"><a href="#建立安全监测机制" class="headerlink" title="建立安全监测机制"></a>建立安全监测机制</h4><p>建立安全监测机制，及时发现并应对恶意爬取行为。通过监控网站访问日志、流量异常等信息，可以及时发现恶意爬虫并采取相应的措施。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>网络安全是互联网发展的基石，而静态内容网站的防爬虫工作是其中的重要一环。防范恶意爬取对于静态内容网站来说至关重要。通过了解恶意爬取的特点和采取相应的防范措施，可以有效提高网站的安全性，维护网站所有者的权益，同时提升用户体验。同时，网站所有者还应持续关注网络安全动态，不断更新和完善防范措施，确保网站内容的安全与稳定。</p>

      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/">network</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/reptile/">reptile</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/security/">security</a></li></ul>

        <a data-url="https://hankliu62.github.io/2024/04/02/security-anti-reptile/" data-id="cluerskl8000buflopesipqxn" class="article-share-link">Share</a>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
    <article id="post-security-sql-injection" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2024/03/31/security-sql-injection/" class="article-date">
  <time datetime="2024-03-31T10:20:26.000Z" itemprop="datePublished">2024-03-31</time>
</h3>
    
  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content fill-content-true">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/03/31/security-sql-injection/">Web安全之 SQL 注入</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <h2 id="Web安全之-SQL-注入"><a href="#Web安全之-SQL-注入" class="headerlink" title="Web安全之 SQL 注入"></a>Web安全之 SQL 注入</h2><p>随着互联网的快速发展，网络安全问题日益受到人们的关注。 <code>SQL</code> 注入是一种常见的网络安全攻击方式，严重威胁着数据库的安全。本文将从 <code>SQL</code> 注入的概念、原理、危害以及防范措施等方面，对网络安全中的 <code>SQL</code> 注入进行深入探讨。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>SQL</code> 注入（<code>SQL Injection</code>）是指攻击者在用户输入的数据中注入恶意的 <code>SQL</code> 语句，从而在未经授权的情况下实现对数据库的非法操作。当应用程序没有对用户输入的数据进行有效的验证和过滤时，攻击者可以利用这一漏洞，篡改原始的 <code>SQL</code> 语句，进而窃取、篡改或删除数据库中的数据。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><code>SQL</code> 注入的原理主要基于应用程序对用户输入数据的处理不当。攻击者通过在用户输入的数据中插入恶意的 <code>SQL</code> 语句，使得应用程序在构建 <code>SQL</code> 查询时，将恶意语句作为查询的一部分发送给数据库执行。这样，攻击者就可以绕过应用程序的验证，直接对数据库进行操作。</p>
<h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><ol>
<li><strong>数据泄露：</strong>攻击者可以通过 <code>SQL</code> 注入获取数据库中的敏感信息，如用户密码、身份信息、银行账户等，从而导致数据泄露和用户隐私泄露。</li>
<li><strong>数据篡改：</strong>攻击者可以利用 <code>SQL</code> 注入修改数据库中的数据，破坏数据的完整性和准确性。</li>
<li><strong>数据删除：</strong>攻击者可以通过 <code>SQL</code> 注入删除数据库中的数据，导致数据丢失和业务受损。</li>
<li><strong>服务器被控制：</strong>攻击者还可以通过 <code>SQL</code> 注入获取数据库的完全控制权限，进一步对服务器进行攻击和控制。</li>
</ol>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>下面是一个简单的 <code>Node.js</code> 和 <code>Express</code> 框架中的 <code>SQL</code> 注入案例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建数据库连接</span></span><br><span class="line"><span class="keyword">const</span> connection = mysql.createConnection(&#123;</span><br><span class="line">  host: <span class="string">'localhost'</span>,</span><br><span class="line">  user: <span class="string">'root'</span>,</span><br><span class="line">  password: <span class="string">'password'</span>,</span><br><span class="line">  database: <span class="string">'test'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">connection.connect();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个简单的路由处理函数，存在 SQL 注入漏洞</span></span><br><span class="line">app.get(<span class="string">'/users'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> username = req.query.username; <span class="comment">// 从查询字符串获取用户名</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直接将用户名插入 SQL 查询中，没有进行任何过滤或转义</span></span><br><span class="line">  <span class="keyword">const</span> query = <span class="string">`SELECT * FROM users WHERE username = '<span class="subst">$&#123;username&#125;</span>'`</span>;</span><br><span class="line"></span><br><span class="line">  connection.query(query, (error, results, fields) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) <span class="keyword">throw</span> error;</span><br><span class="line">    res.send(results);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'App listening on port 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在上述代码中，我们定义了一个简单的 <code>Express</code> 应用，它监听 <code>/users</code> 路由，并从查询字符串中获取 <code>username</code> 参数。然后，我们直接将 <code>username</code> 插入 <code>SQL</code> 查询语句中。由于没有对 <code>username</code> 进行任何形式的过滤或转义，攻击者可以通过在查询字符串中插入恶意的 <code>SQL</code> 代码来操纵查询结果，甚至执行任意的 <code>SQL</code> 语句。</p>
<p>例如，攻击者可以通过以下 <code>URL</code> 尝试注入攻击：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:3000/users?username=&apos;; DROP TABLE users; --</span><br></pre></td></tr></table></figure>
<p>这个 <code>URL</code> 会导致 <code>SQL</code> 查询变成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> username = <span class="string">''</span>; <span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">users</span>; <span class="comment">--'</span></span><br></pre></td></tr></table></figure>
<p>如果应用执行了这条查询，它会删除 <code>users</code> 表中的所有数据。</p>
<h3 id="防范措施"><a href="#防范措施" class="headerlink" title="防范措施"></a>防范措施</h3><p>为了防止 <code>SQL</code> 注入攻击，你应该：</p>
<h4 id="使用参数化查询"><a href="#使用参数化查询" class="headerlink" title="使用参数化查询"></a>使用参数化查询</h4><p>参数化查询可以确保用户输入被当作数据而不是 <code>SQL</code> 代码来处理。在 <code>Node.js</code> 中，可以使用像 <code>mysql</code> 包中的 <code>query</code> 方法的参数化版本，或者使用 <code>ORM</code>（对象关系映射）库如 <code>Sequelize</code> 或者 <code>TypeORM</code>。</p>
<p>在上述的 <code>Node.js</code> 例子中，你可以使用 <code>mysql</code> 包来执行参数化查询。以下是一个使用 <code>mysql</code> 包和参数化查询来预防 <code>SQL</code> 注入的示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/users'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> username = req.query.username; <span class="comment">// 从查询字符串获取用户名</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建 SQL 语句</span></span><br><span class="line">  <span class="keyword">const</span> query = <span class="string">`SELECT * FROM users WHERE username = '?'`</span>;</span><br><span class="line"></span><br><span class="line">  connection.query(query, [username], (error, results, fields) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) <span class="keyword">throw</span> error;</span><br><span class="line">    res.send(results);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>?</code>是一个参数占位符，代表我们要查询的 <code>username</code>。我们将 <code>username</code> 作为数组 <code>[username]</code> 的元素传递给 <code>query</code> 方法的第二个参数。这样，<code>MySQL</code> 驱动程序就会知道 <code>?</code> 应该被 <code>username</code> 的值替换。</p>
<p>由于参数化查询确保了用户输入被当作数据处理，而不是作为 <code>SQL</code> 代码的一部分，因此即使 <code>username</code> 包含恶意的 <code>SQL</code> 代码，它也不会被执行。这是预防 <code>SQL</code> 注入攻击的一种有效方式。</p>
<h4 id="使用预编译语句"><a href="#使用预编译语句" class="headerlink" title="使用预编译语句"></a>使用预编译语句</h4><p>预编译语句是一种将 <code>SQL</code> 语句和参数分开处理的方式，数据库管理系统会对 <code>SQL</code> 语句进行解析、优化和编译，然后存储起来。每次执行时，只需传递参数，避免了 <code>SQL</code> 注入的风险。</p>
<p>在上述的 <code>Node.js</code> 例子中，你可以使用 <code>mysql</code> 包来执行预编译语句。以下是一个使用 <code>mysql</code> 包和预编译语句来预防 <code>SQL</code> 注入的示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/users'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> username = req.query.username; <span class="comment">// 从查询字符串获取用户名</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备预编译语句</span></span><br><span class="line">  <span class="keyword">const</span> prepareQuery = <span class="string">`PREPARE stmt FROM "SELECT * FROM users WHERE username = '?'"`</span>;</span><br><span class="line">  connection.query(prepareQuery, (error, results, fields) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) <span class="keyword">throw</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置参数并执行预编译语句</span></span><br><span class="line">    <span class="keyword">const</span> executeQuery = <span class="string">'EXECUTE stmt USING ?'</span>;</span><br><span class="line">    connection.query(executeQuery, [username], (error, results, fields) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">throw</span> error;</span><br><span class="line">      <span class="built_in">console</span>.log(results);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 释放预编译语句</span></span><br><span class="line">      connection.query(<span class="string">'DEALLOCATE PREPARE stmt'</span>, (error) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) <span class="keyword">throw</span> error;</span><br><span class="line">        connection.end();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在这个预编译语句的例子中，我们首先准备一个预编译语句，其中包含一个占位符 <code>?</code>。然后，我们使用 <code>PREPARE</code> 语句将其发送到数据库进行编译。之后，我们使用 <code>EXECUTE</code> 语句并传递参数 <code>[username]</code> 来执行预编译的语句。最后，我们使用 <code>DEALLOCATE PREPARE</code> 语句释放预编译语句的资源。</p>
<p>使用预编译语句的好处是，即使参数中包含恶意的 <code>SQL</code> 代码，它也不会被数据库执行。这是因为预编译语句将参数和 <code>SQL</code> 语句分开处理，数据库只会执行预编译的 <code>SQL</code> 语句，并将参数作为数据来处理。</p>
<h4 id="转义用户输入"><a href="#转义用户输入" class="headerlink" title="转义用户输入"></a>转义用户输入</h4><p>转义用户输入是另一种防止 <code>SQL</code> 注入攻击的方法。转义用户输入意味着将用户提供的值中的特殊字符（如单引号、双引号等）替换为它们的转义版本，这样在 <code>SQL</code> 语句中它们就会被当作普通文本处理，而不是 <code>SQL</code> 代码的一部分。</p>
<p>虽然参数化查询是首选的方法，因为它提供了更高级别的安全性，但在某些情况下，你可能需要手动转义用户输入。在 <code>Node.js</code> 中，你可以使用 <code>MySQL</code> 驱动程序的 <code>escape</code> 方法来转义用户输入。</p>
<p>以下是一个使用 <code>Node.js</code> 和 <code>mysql</code> 驱动程序手动转义用户输入的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/users'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 从查询字符串获取用户名</span></span><br><span class="line">  <span class="keyword">const</span> username = req.query.username;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 escape 方法转义用户输入</span></span><br><span class="line">  <span class="keyword">const</span> safeUsername = mysql.escape(username);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建 SQL 语句</span></span><br><span class="line">  <span class="keyword">const</span> query = <span class="string">`SELECT * FROM users WHERE username = '<span class="subst">$&#123;safeUsername&#125;</span>'`</span>;</span><br><span class="line"></span><br><span class="line">  connection.query(query, (error, results, fields) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) <span class="keyword">throw</span> error;</span><br><span class="line">    res.send(results);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们使用了 <code>mysql.escape</code> 方法来转义 <code>username</code> 中的特殊字符。这样，即使 <code>username</code> 包含特殊字符，它也不会被误解为 <code>SQL</code> 语句的一部分。</p>
<p>然而，尽管手动转义用户输入可以提供一定程度的保护，但它仍然不是最安全的做法。原因之一是它可能会导致程序逻辑变得复杂且容易出错，尤其是在构建复杂的 <code>SQL</code> 语句时。因此，推荐使用参数化查询或预编译语句，因为它们提供了更强的安全性保证，并且更容易正确使用。</p>
<h4 id="最小权限原则"><a href="#最小权限原则" class="headerlink" title="最小权限原则"></a>最小权限原则</h4><p>确保数据库账户只有执行必要操作的最小权限。例如，如果应用程序只需要从数据库中读取数据，那么就不应该赋予它写入权限。</p>
<p>在 <code>MySQL</code> 中设置只读权限，你需要登录到MySQL数据库，然后为用户创建一个新的角色并授予只读权限。你可以使用GRANT语句来实现这一点。具体如下所示:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 登录到MySQL</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建新角色</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ROLE</span> <span class="string">'readonlyuser'</span>@<span class="string">'localhost'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 授予只读权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> your_database.* <span class="keyword">TO</span> <span class="string">'readonlyuser'</span>@<span class="string">'localhost'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 刷新权限</span></span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 退出MySQL</span></span><br><span class="line">EXIT;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>your_database</code> 是你想要让用户具有只读权限的数据库名。<code>&#39;readonlyuser&#39;@&#39;localhost&#39;</code> 表示用户名为 <code>readonlyuser</code> ，并且该用户只能从本地主机连接到数据库。如果你希望用户可以从任何主机连接，你可以将 <code>localhost</code> 替换为 <code>&#39;%&#39;</code>。</p>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>不要将详细的数据库错误信息直接返回给用户。这可以防止攻击者利用这些信息进行更复杂的攻击。</p>
<h4 id="安全审计和测试"><a href="#安全审计和测试" class="headerlink" title="安全审计和测试"></a>安全审计和测试</h4><p>使用工具如 <code>SQLMap</code>、<code>OWASP Zap</code> 等进行安全审计和测试，确保应用程序不会受到 <code>SQL</code> 注入攻击。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总之， <code>SQL</code> 注入是一种常见的网络安全攻击方式，对数据库的安全构成严重威胁。为了防范 <code>SQL</code> 注入攻击，我们需要加强用户输入验证、使用参数化查询、存储过程等安全措施，并定期更新和修补数据库管理系统和应用程序。只有这样，我们才能确保数据库的安全，保护用户的数据隐私和业务安全。</p>

      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/">network</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/security/">security</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/sql/">sql</a></li></ul>

        <a data-url="https://hankliu62.github.io/2024/03/31/security-sql-injection/" data-id="cluersklh000muflohbuwzwdl" class="article-share-link">Share</a>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
    <article id="post-thread-loader" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2024/03/30/thread-loader/" class="article-date">
  <time datetime="2024-03-30T02:10:20.000Z" itemprop="datePublished">2024-03-30</time>
</h3>
    
  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content fill-content-true">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/03/30/thread-loader/">thread-loader</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <h2 id="thread-loader"><a href="#thread-loader" class="headerlink" title="thread-loader"></a>thread-loader</h2><p><code>thread-loader</code> 是一种在 <code>worker</code> 池中运行以下 <code>loader</code> 的工具。</p>
<h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><p>通过 npm、yarn 或 pnpm 安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev thread-loader</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D thread-loader</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm add -D thread-loader</span><br></pre></td></tr></table></figure>
<p>将其放在其他 <code>loader</code> 的前面，以下 <code>loader</code> 将在 <code>worker</code> 池中运行。</p>
<p>在 <code>worker</code> 池中运行的 <code>loader</code> 有一些限制。例如：</p>
<ul>
<li><code>loader</code> 不能发射文件。</li>
<li><code>loader</code> 不能使用自定义 <code>loader API</code>（即插件）。</li>
<li><code>loader</code> 不能访问 <code>webpack</code> 配置项。</li>
</ul>
<p>每个 <code>worker</code> 是一个单独的 <code>node.js</code> 进程，启动一个 <code>worker</code> 大约需要 600ms 的时间。此外，进程间通信也存在一定的开销。</p>
<p>因此，仅将此 <code>loader</code> 用于计算密集型操作！</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        include: path.resolve(<span class="string">'src'</span>),</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'thread-loader'</span>,</span><br><span class="line">          <span class="comment">// 你的计算密集型 loader（例如 babel-loader）</span></span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="带有选项"><a href="#带有选项" class="headerlink" title="带有选项"></a>带有选项</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">use: [</span><br><span class="line">  &#123;</span><br><span class="line">    loader: <span class="string">'thread-loader'</span>,</span><br><span class="line">    <span class="comment">// 选项相同的 loader 将共享 worker 池</span></span><br><span class="line">    options: &#123;</span><br><span class="line">      <span class="comment">// 生成的 worker 数量，默认为（CPU 核心数 - 1）或当 require('os').cpus() 未定义时回退到 1</span></span><br><span class="line">      workers: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 一个 worker 并行处理的 job 数量</span></span><br><span class="line">      <span class="comment">// 默认为 20</span></span><br><span class="line">      workerParallelJobs: <span class="number">50</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 额外的 node.js 参数</span></span><br><span class="line">      workerNodeArgs: [<span class="string">'--max-old-space-size=1024'</span>],</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 允许重新生成已死亡的 worker 池</span></span><br><span class="line">      <span class="comment">// 重新生成会减慢整个编译速度</span></span><br><span class="line">      <span class="comment">// 在开发环境中应将其设置为 false</span></span><br><span class="line">      poolRespawn: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当空闲时杀死 worker 进程的超时时间</span></span><br><span class="line">      <span class="comment">// 默认为 500 (ms)</span></span><br><span class="line">      <span class="comment">// 对于保持 worker 存活的监视构建，可以设置为 Infinity</span></span><br><span class="line">      poolTimeout: <span class="number">2000</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 池分配给 worker 的工作数量</span></span><br><span class="line">      <span class="comment">// 默认为 200</span></span><br><span class="line">      <span class="comment">// 降低这个数值会降低总体的效率，但是会提升工作分布更均一</span></span><br><span class="line">      poolParallelJobs: <span class="number">50</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 池的名称</span></span><br><span class="line">      <span class="comment">// 可以修改名称来创建其余选项都一样的池</span></span><br><span class="line">      name: <span class="string">"my-pool"</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 耗时的 loader（例如 babel-loader）</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<h3 id="预热"><a href="#预热" class="headerlink" title="预热"></a>预热</h3><p>为了防止在启动 <code>worker</code> 时出现高延迟，可以预热 <code>worker</code> 池。</p>
<p>这将启动池中的最大 <code>worker</code> 数量，并将指定的模块加载到 <code>node.js</code> 模块缓存中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> threadLoader = <span class="built_in">require</span>(<span class="string">'thread-loader'</span>);</span><br><span class="line"></span><br><span class="line">threadLoader.warmup(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 池选项，像传递给 loader 选项那样</span></span><br><span class="line">    <span class="comment">// 必须匹配 loader 选项以启动正确的池</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [</span><br><span class="line">    <span class="comment">// 要加载的模块</span></span><br><span class="line">    <span class="comment">// 可以是任何模块，例如</span></span><br><span class="line">    <span class="string">'babel-loader'</span>,</span><br><span class="line">    <span class="string">'babel-preset-es2015'</span>,</span><br><span class="line">    <span class="string">'sass-loader'</span>,</span><br><span class="line">  ]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/loader/">loader</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/">webpack</a></li></ul>

        <a data-url="https://hankliu62.github.io/2024/03/30/thread-loader/" data-id="cluersklf000iufloi2whnog3" class="article-share-link">Share</a>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
    <article id="post-vitepress-blog-guide" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2024/03/29/vitepress-blog-guide/" class="article-date">
  <time datetime="2024-03-29T04:20:26.000Z" itemprop="datePublished">2024-03-29</time>
</h3>
    
  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content fill-content-true">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/03/29/vitepress-blog-guide/">使用VitePress搭建个人博客</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <h2 id="使用-VitePress-搭建个人博客"><a href="#使用-VitePress-搭建个人博客" class="headerlink" title="使用 VitePress 搭建个人博客"></a>使用 VitePress 搭建个人博客</h2><p>随着互联网的迅猛发展，内容创作与分享已成为人们日常生活的重要组成部分。博客网站作为内容分享的重要平台，其构建工具的选择对于内容创作者来说至关重要。以前构建 <code>github pages</code> 内容博客站点，我们一般使用 <code>Hexo</code> 框架，但其构建速度相对较慢，博客风格依赖于 <code>hexo-theme</code>，大多数 <code>hexo-theme</code> 的开发都使用 <code>ejs</code> 模板引擎，不熟悉而且使用起来相对麻烦。而随着 <code>VitePress</code> 的出现，其构建速度也得到了优化，而且以 <code>Vite</code> 为基础，构建速度更快，更适合于构建博客站点，支持使用 <code>Vue</code> 进行定制化开发，很方便的创建自定义风格的博客站点。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>VitePress</code> 是由 <code>Vue.js</code> 驱动的静态网站生成器，专为技术文档和博客设计。它结合了 <code>Vite</code> 的快速冷启动和 <code>Vue.js</code> 的组件化开发优势，为用户提供了一个快速、简单且优雅的博客搭建方案。使用 <code>VitePress</code> ，您可以轻松创建、发布和管理博客内容，同时还能够享受到 <code>Vue.js</code> 带来的丰富交互体验。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li><strong>高效构建：</strong> <code>VitePress</code> 利用 <code>Vite</code> 的高速构建特性，实现了快速的页面加载和实时预览功能，大大提高了内容创作的效率。</li>
<li><strong>Markdown支持：</strong> <code>VitePress</code> 原生支持 <code>Markdown</code> 语法，让您能够轻松编写格式化的文章内容，无需担心排版问题。</li>
<li><strong>Vue.js集成：</strong> 作为 <code>Vue.js</code> 驱动的生成器， <code>VitePress</code> 允许您在博客中嵌入 <code>Vue</code> 组件，实现丰富的交互效果和动态内容。</li>
<li><strong>主题定制：</strong> <code>VitePress</code> 提供了丰富的主题选项，您可以根据自己的喜好和需求定制博客的外观风格。</li>
<li><strong>部署简便：</strong> 生成的静态网站可以方便地部署到各种平台，如 <code>GitHub Pages</code> 、 <code>Netlify</code> 等，无需额外的服务器配置。</li>
</ol>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="安装-Homebrew"><a href="#安装-Homebrew" class="headerlink" title="安装 Homebrew"></a>安装 <code>Homebrew</code></h4><p><code>Homebrew</code> 是一种开源包管理器，主要用于 <code>macOS</code> 和 <code>Linux</code> 系统，可以理解为一个命令行版本的应用商店</p>
<p><code>Homebrew</code> 是基于Ruby的，所以安装过程也是很简单的，把下面的代码粘贴到 <code>Terminal</code> 中执行</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure>
<p>查看安装是否成功:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew --version</span><br></pre></td></tr></table></figure>
<p>如下图所示表示安装成功</p>
<p><img src="https://user-images.githubusercontent.com/8088864/30236069-ba7e712e-9544-11e7-910a-7ec04c1d5579.png" alt="image"></p>
<h4 id="通过-nvm-安装指定版本的-Node"><a href="#通过-nvm-安装指定版本的-Node" class="headerlink" title="通过 nvm 安装指定版本的 Node"></a>通过 <code>nvm</code> 安装指定版本的 <code>Node</code></h4><ol>
<li>安装 <code>nvm</code></li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install nvm</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>配置 <code>nvm</code></li>
</ol>
<p>配置 <code>nvm</code> 在 <code>shell</code> 中可以使用 <code>nvm</code> 命令，修改<code>~/.bash_profile</code>文件，如果不存在，新建<code>.bash_profile</code>文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">vim .bash_profile</span><br></pre></td></tr></table></figure>
<p>在文件中添加如下命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export NVM_DIR=~/.nvm</span><br><span class="line">source $(brew --prefix nvm)/nvm.sh</span><br></pre></td></tr></table></figure>
<p>重新 <code>source</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> .bash_profile</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>安装 <code>Node</code></li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nvm ls-remote</span><br><span class="line"><span class="comment"># 安装node 18</span></span><br><span class="line">nvm install 18</span><br></pre></td></tr></table></figure>
<p>其他的 <code>nvm</code> 命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nvm ls-remote 查看 所有的node可用版本</span><br><span class="line"></span><br><span class="line">nvm install xxx 下载你想要的版本</span><br><span class="line"></span><br><span class="line">nvm use xxx 使用指定版本的node</span><br><span class="line"></span><br><span class="line">nvm <span class="built_in">alias</span> default xxx 每次启动终端都使用该版本的node</span><br></pre></td></tr></table></figure>
<h4 id="通过-npm-全局安装-VitePress"><a href="#通过-npm-全局安装-VitePress" class="headerlink" title="通过 npm 全局安装 VitePress"></a>通过 <code>npm</code> 全局安装 <code>VitePress</code></h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g vitepress</span><br></pre></td></tr></table></figure>
<h3 id="使用VitePress制作博客网站"><a href="#使用VitePress制作博客网站" class="headerlink" title="使用VitePress制作博客网站"></a>使用VitePress制作博客网站</h3><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><ol>
<li>初始化个人博客项目</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir my-blog</span><br><span class="line"><span class="built_in">cd</span> my-blog</span><br><span class="line">npm init -y</span><br><span class="line">yarn add vitepress --dev</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/hankliu62/hankliu62.github.com/assets/8088864/dc34ca12-aaf2-443b-a73e-d93f217e8be7" alt="image"></p>
<ol start="2">
<li>使用 <code>VitePress</code> 命令初始化配置</li>
</ol>
<p>设置配置文件的名称和路径，标题，描述，主题和基本配置相关信息</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vitepress init</span><br><span class="line"></span><br><span class="line">yarn add vue --dev</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/hankliu62/hankliu62.github.com/assets/8088864/d425e214-8add-4f0f-aae1-2229a47a0430" alt="image"></p>
<h4 id="编写文章"><a href="#编写文章" class="headerlink" title="编写文章"></a>编写文章</h4><p>在项目的根目录下找到一个名为docs的文件夹，这将作为你的博客内容的根目录。然后，在docs文件夹中修改以下文件：</p>
<ul>
<li>index.md：作为博客的主页。</li>
<li>_sidebar.md：定义侧边栏的导航菜单。</li>
<li>其他以.md结尾的Markdown文件：作为博客的具体文章。</li>
</ul>
<p><img src="https://github.com/hankliu62/hankliu62.github.com/assets/8088864/d3be51ea-7da3-4731-9030-523173399276" alt="image"></p>
<h4 id="配置VitePress"><a href="#配置VitePress" class="headerlink" title="配置VitePress"></a>配置VitePress</h4><p>在项目的根目录下找到一个名为docs的文件夹，里面存在 <code>.vitepress/config.mts</code> 的文件，用于配置 <code>VitePress</code> 的行为。以下是一个基本的配置示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vitepress.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  title: <span class="string">'HankLiu的博客小屋'</span>, <span class="comment">// 博客的标题</span></span><br><span class="line">  description: <span class="string">'努力去听风的声音，不必在意风的方向。'</span>, <span class="comment">// 博客的描述</span></span><br><span class="line">  themeConfig: &#123;</span><br><span class="line">    nav: [ <span class="comment">// 导航栏配置</span></span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">'主页'</span>, <span class="attr">link</span>: <span class="string">'/'</span> &#125;,</span><br><span class="line">      <span class="comment">// 其他导航项...</span></span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    sidebar: &#123; <span class="comment">// 侧边栏配置</span></span><br><span class="line">      <span class="string">'/'</span>: [ <span class="comment">// 主页侧边栏</span></span><br><span class="line">        <span class="string">''</span>, <span class="comment">// 主页链接</span></span><br><span class="line">        <span class="comment">// 其他文章链接...</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="comment">// 其他页面的侧边栏配置...</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    socialLinks: [ <span class="comment">// 社交链接配置</span></span><br><span class="line">      &#123; <span class="attr">icon</span>: <span class="string">'github'</span>, <span class="attr">link</span>: <span class="string">'https://github.com/xxx'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 其他配置...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="启动预览"><a href="#启动预览" class="headerlink" title="启动预览"></a>启动预览</h4><p>运行 <code>VitePress</code> 命令，本地启动博客预览。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn docs:dev</span><br></pre></td></tr></table></figure>
<p>这将启动一个本地开发服务器，你可以在浏览器中访问 <code>http://localhost:5173/</code> 来查看你的博客网站。</p>
<h5 id="报错-getaddrinfo-ENOTFOUND-localhost"><a href="#报错-getaddrinfo-ENOTFOUND-localhost" class="headerlink" title="报错 getaddrinfo ENOTFOUND localhost"></a>报错 <code>getaddrinfo ENOTFOUND localhost</code></h5><p><img src="https://github.com/hankliu62/hankliu62.github.com/assets/8088864/c8d10f7c-0cc3-4e30-bea1-ab9e9f5770f0" alt="image"></p>
<p><code>getaddrinfo ENOTFOUND localhost</code> 错误表明 <code>Node.js</code> 在尝试解析主机名 <code>localhost</code> 对应的 <code>IP</code> 地址时失败了。这通常意味着 <code>localhost</code> 无法被解析，可能是因为 <code>DNS</code> 解析问题或者本地 <code>DNS</code> 缓存出现问题。</p>
<p>检查 <code>/etc/hosts</code> 文件（在 Unix-like 系统中）或 <code>C:\Windows\System32\drivers\etc\hosts</code>（在 Windows 中），确保 <code>localhost</code> 正确地指向 <code>127.0.0.1</code></p>
<p>解决方法：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br><span class="line"><span class="comment"># 添加一行：127.0.0.1 localhost</span></span><br><span class="line">sudo killall -HUP mDNSResponder</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/hankliu62/hankliu62.github.com/assets/8088864/805bf9c4-2e98-4333-9a2d-2faab5002d33" alt="image"></p>
<h4 id="生成静态网站"><a href="#生成静态网站" class="headerlink" title="生成静态网站"></a>生成静态网站</h4><p>当你的博客网站开发完成后，可以使用以下命令来构建生产版本的网站：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn docs:build</span><br></pre></td></tr></table></figure>
<p>构建完成后，<code>VitePress</code> 将在 <code>docs/.vitepress/dist</code> 文件夹中生成静态文件。你可以将这些文件部署到你选择的任何Web服务器上，或者将它们上传到诸如 <code>GitHub Pages</code> 之类的服务上。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p><code>VitePress</code> 作为一款专为内容创作者设计的博客构建工具，凭借其高效、便捷的特性，为内容创作者提供了一个理想的博客搭建方案。无论是个人博客还是企业技术文档， <code>VitePress</code> 都能够帮助您快速搭建起一个美观、实用的博客网站，让您的内容更好地传播和分享。</p>

      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/blog/">blog</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vitepress/">vitepress</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/">vue</a></li></ul>

        <a data-url="https://hankliu62.github.io/2024/03/29/vitepress-blog-guide/" data-id="cluersklu000uuflou0jdc0gy" class="article-share-link">Share</a>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
    <article id="post-security-csrf" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2024/03/27/security-csrf/" class="article-date">
  <time datetime="2024-03-27T02:40:20.000Z" itemprop="datePublished">2024-03-27</time>
</h3>
    
  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content fill-content-true">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/03/27/security-csrf/">Web安全之 CSRF 攻击</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <h2 id="Web安全之-CSRF-攻击"><a href="#Web安全之-CSRF-攻击" class="headerlink" title="Web安全之 CSRF 攻击"></a>Web安全之 CSRF 攻击</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>CSRF</code>是跨站请求伪造（<code>Cross-Site Request Forgery</code>）的缩写。跨站请求伪造是一种网络攻击方式，攻击者利用已登录的用户在浏览器中存储的合法会话信息，伪造用户发出的请求，以达到欺骗服务器的目的。这种攻击方式并不涉及窃取用户的会话信息，而是利用会话信息。攻击者通常会在用户毫不知情的情况下，在用户的浏览器上执行恶意操作，如更改密码、发布信息、购买商品等。</p>
<h3 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h3><p><code>CSRF</code>的攻击原理基于Web的隐式身份验证机制。在用户访问Web应用时，浏览器会自动携带用户的会话凭证（如<code>Cookie</code>），以便服务器能够识别用户的身份。攻击者通过构造一个恶意网站或链接，诱使用户访问该网站或点击链接，从而触发一个针对目标网站的伪造请求。由于浏览器会自动携带用户的会话凭证，目标网站无法区分正常请求和伪造请求，因此会执行伪造请求中的操作。</p>
<h3 id="攻击目标"><a href="#攻击目标" class="headerlink" title="攻击目标"></a>攻击目标</h3><p><code>CSRF</code>的攻击目标主要是需要用户身份认证的操作，如修改用户信息、更改密码、发表评论、进行转账等。攻击者希望利用用户的身份执行这些操作，以达到窃取数据、篡改内容、转移资金等目的。</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ol>
<li>受害者登录 a.com，并保留了登录凭证（Cookie）</li>
<li>攻击者引诱受害者访问了b.com</li>
<li>b.com 向 a.com 发送了一个请求：a.com/act=xx浏览器会默认携带a.com的Cookie</li>
<li>a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求</li>
<li>a.com以受害者的名义执行了act=xx</li>
<li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作</li>
</ol>
<p>例如: 攻击者构造一个伪造的银行转账请求，诱导受害者点击后，该请求会携带受害者的cookie信息，并向正常站点发起请求，从而完成非法转账。或者攻击者设置了一个自动转发邮件的规则，使得受害者的所有邮件都被自动转发到攻击者的邮箱中。</p>
<h3 id="预防方案"><a href="#预防方案" class="headerlink" title="预防方案"></a>预防方案</h3><p><code>CSRF</code>通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性。</p>
<ol>
<li><p><code>同源检测</code>：通过 <code>Header</code> 中的 <code>Origin Header</code> 、<code>Referrer Header</code> 确定，但不同浏览器可能会有不一样的实现，不能完全保证</p>
</li>
<li><p><code>CSRF Token 校验</code>：将 <code>CSRF Token</code>输出到页面中（通常保存在 <code>Session</code> 中），页面提交的请求携带这个 <code>Token</code> ，服务器验证 <code>Token</code> 是否正确</p>
</li>
<li><p><code>双重cookie验证</code>：</p>
<ul>
<li>流程：<ul>
<li>步骤1：在用户访问网站页面时，向请求域名注入一个<code>Cookie</code>，内容为随机字符串（例如<code>csrfcookie=v8g9e4ksfhw</code>）</li>
<li>步骤2：在前端向后端发起请求时，取出<code>Cookie</code>，并添加到<code>URL</code>的参数中（接上例POST <code>https://www.a.com/comment?csrfcookie=v8g9e4ksfhw</code>）</li>
<li>步骤3：后端接口验证<code>Cookie</code>中的字段与<code>URL</code>参数中的字段是否一致，不一致则拒绝。</li>
</ul>
</li>
<li>优点：<ul>
<li>无需使用<code>Session</code>，适用面更广，易于实施。</li>
<li><code>Token</code>储存于客户端中，不会给服务器带来压力。</li>
<li>相对于<code>Token</code>，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。</li>
</ul>
</li>
<li>缺点：<ul>
<li><code>Cookie</code>中增加了额外的字段。</li>
<li>如果有其他漏洞（例如<code>XSS</code>），攻击者可以注入<code>Cookie</code>，那么该防御方式失效。</li>
<li>难以做到子域名的隔离。</li>
<li>为了确保<code>Cookie</code>传输安全，采用这种防御方式的最好确保用整站HTTPS的方式，如果还没切HTTPS的使用这种方式也会有风险。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>SameSite Cookie属性</code>：<code>Cookie</code>的<code>SameSite</code>属性是一种安全策略，用于限制第三方网站获取<code>Cookie</code>的能力，从而增强网站的安全性。<code>SameSite</code>属性可以设置三个值，分别是：</p>
<ul>
<li><code>Strict</code>：完全禁止第三方获取<code>Cookie</code>，只有在当前网页的<code>URL</code>与请求目标一致时，才会带上<code>Cookie</code>。这种设置可能会对用户体验造成一定的影响，例如，在跳转到其他网站时，可能会因为未携带<code>Cookie</code>而导致登录状态丢失。</li>
<li><code>Lax</code>：比<code>Strict</code>宽松一些，允许在跨站使用<code>GET</code>请求时携带<code>Cookie</code>。例如，在通过链接进行页面跳转时，会带上<code>Cookie</code>，但在通过表单提交数据时，不会带上<code>Cookie</code>。</li>
<li><code>None</code>：允许在任何情况下都携带<code>Cookie</code>。但是，为了安全起见，当设置为None时，必须同时设置<code>Secure</code>属性，即<code>Cookie</code>只能通过<code>HTTPS</code>协议发送，否则设置将无效。</li>
</ul>
</li>
<li><p>验证码：在关键操作或敏感操作前，要求用户输入验证码。这样即使攻击者能够构造伪造请求，也无法自动执行操作，因为需要用户手动输入验证码。</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>CSRF是一种严重的网络威胁，对于需要用户身份认证的操作尤其危险。为了保障用户数据的安全性和隐私保护，开发人员在设计和开发网络应用时，应该充分考虑CSRF攻击的防御措施，并采取多种手段提高系统的安全性。同时，用户也应该保持警惕，避免点击不明来源的链接或访问可疑网站，以防止CSRF攻击的发生。</p>

      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/csrf/">csrf</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/">network</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/security/">security</a></li></ul>

        <a data-url="https://hankliu62.github.io/2024/03/27/security-csrf/" data-id="cluersklc000fuflo78c0yb0u" class="article-share-link">Share</a>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
    <article id="post-security-xss" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2024/03/14/security-xss/" class="article-date">
  <time datetime="2024-03-14T02:10:20.000Z" itemprop="datePublished">2024-03-14</time>
</h3>
    
  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content fill-content-true">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/03/14/security-xss/">Web安全之 XSS 攻击</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Web安全之-XSS-攻击"><a href="#Web安全之-XSS-攻击" class="headerlink" title="Web安全之 XSS 攻击"></a>Web安全之 XSS 攻击</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>XSS，全称跨站脚本攻击（Cross-Site Scripting）</strong>，是一种网络安全漏洞攻击，指攻击者在网页中嵌入恶意脚本，当其他用户浏览该网页时，恶意脚本就会在其浏览器上执行，从而达到攻击者窃取用户信息、破坏数据、篡改网页内容、在用户浏览器上执行非法任务等目的。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><code>XSS</code>攻击分为三种类型：</p>
<ul>
<li><p><strong>反射型XSS（Reflected XSS）</strong>：攻击者将恶意脚本嵌入到URL地址中，当其他用户访问这个URL时，恶意脚本就会在其浏览器中执行。这种攻击方式需要用户主动点击含有恶意脚本的链接才会触发。</p>
</li>
<li><p><strong>存储型XSS（Stored XSS）</strong>：攻击者将恶意脚本存储到被攻击的网站数据库中，当其他用户访问网站时，恶意脚本会从数据库中取出并在用户浏览器中执行。这种攻击方式不需要用户主动点击链接，只要用户浏览被攻击的网站就可能被攻击。</p>
</li>
<li><p><strong>DOM型XSS（DOM-based XSS）</strong>：攻击者通过修改页面的DOM结构，注入恶意脚本，当其他用户浏览该页面时，恶意脚本会在用户浏览器中执行。这种攻击方式也不需要用户主动点击链接，只需要用户浏览被修改的页面就可能被攻击。</p>
</li>
</ul>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h4><p>在<code>Node.js</code>中，一个反射型<code>XSS</code>攻击的案例可能涉及一个web应用，该应用没有正确地处理或转义用户输入的数据，并将其直接插入到HTML响应中。攻击者可以构造一个包含恶意脚本的URL，当其他用户访问这个URL时，恶意脚本会在用户的浏览器中执行。</p>
<p>以下是一个简单的<code>Node.js</code>反射型<code>XSS</code>攻击的案例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(express.static(<span class="string">'public'</span>));</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/profile'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 假设用户可以通过URL参数传递他们的名字</span></span><br><span class="line">  <span class="keyword">const</span> username = req.query.username;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有对用户输入进行任何处理或转义</span></span><br><span class="line">  <span class="keyword">const</span> html = <span class="string">`&lt;html&gt;</span></span><br><span class="line"><span class="string">                &lt;body&gt;</span></span><br><span class="line"><span class="string">                  &lt;h1&gt;Welcome, <span class="subst">$&#123;username&#125;</span>!&lt;/h1&gt;</span></span><br><span class="line"><span class="string">                &lt;/body&gt;</span></span><br><span class="line"><span class="string">              &lt;/html&gt;`</span>;</span><br><span class="line"></span><br><span class="line">  res.send(html);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PORT = process.env.PORT || <span class="number">3000</span>;</span><br><span class="line">app.listen(PORT, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Server is running on port <span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们创建了一个简单的<code>Express</code>应用，其中有一个<code>/profile</code>路由，该路由从URL的查询参数中获取用户名（<code>username</code>）。然后，我们将这个用户名嵌入到一个<code>HTML</code>字符串中，并将其作为响应发送回客户端。</p>
<p>攻击者可以构造一个包含恶意脚本的URL，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/profile?username=&lt;script&gt;alert(&apos;XSS&apos;);&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>当用户访问这个<code>URL</code>时，浏览器会接收到包含恶意脚本的<code>HTML</code>响应，并执行该脚本，从而触发<code>XSS</code>攻击。</p>
<p>为了防止反射型<code>XSS</code>攻击，开发者应该对用户输入进行适当的过滤和转义。在这个案例中，可以使用如<code>escape-html</code>这样的库来转义<code>HTML</code>特殊字符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> escapeHtml = <span class="built_in">require</span>(<span class="string">'escape-html'</span>);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/profile'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> username = req.query.username;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 转义用户输入中的HTML特殊字符</span></span><br><span class="line">  <span class="keyword">const</span> escapedUsername = escapeHtml(username);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> html = <span class="string">`&lt;html&gt;</span></span><br><span class="line"><span class="string">                &lt;body&gt;</span></span><br><span class="line"><span class="string">                  &lt;h1&gt;Welcome, <span class="subst">$&#123;escapedUsername&#125;</span>!&lt;/h1&gt;</span></span><br><span class="line"><span class="string">                &lt;/body&gt;</span></span><br><span class="line"><span class="string">              &lt;/html&gt;`</span>;</span><br><span class="line"></span><br><span class="line">  res.send(html);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通过转义用户输入，恶意脚本将不会被浏览器执行，从而防止了<code>XSS</code>攻击。此外，开发者还应该使用内容安全策略（<code>CSP</code>）等额外安全措施来增强应用的安全性。</p>
        
          <p class="article-more-link">
            <a href="/2024/03/14/security-xss/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/">network</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/security/">security</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/xss/">xss</a></li></ul>

        <a data-url="https://hankliu62.github.io/2024/03/14/security-xss/" data-id="cluersklm000ouflojjjtuhkr" class="article-share-link">Share</a>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
    <article id="post-security-x-content-types-options" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2024/03/13/security-x-content-types-options/" class="article-date">
  <time datetime="2024-03-13T01:09:12.000Z" itemprop="datePublished">2024-03-13</time>
</h3>
    
  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content fill-content-true">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/03/13/security-x-content-types-options/">Web安全之使用 X-Content-Type-Options 首部字段</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <h2 id="Web安全之使用-X-Content-Type-Options-首部字段"><a href="#Web安全之使用-X-Content-Type-Options-首部字段" class="headerlink" title="Web安全之使用 X-Content-Type-Options 首部字段"></a>Web安全之使用 X-Content-Type-Options 首部字段</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>X-Content-Type-Options</code> 是一个 <code>HTTP</code> 响应头，用于防止浏览器对响应内容的 <code>MIME</code> 类型进行嗅探或猜测。当设置为 <code>nosniff</code> 时，它告诉浏览器应该严格按照响应头中 <code>Content-Type</code> 字段所指定的类型来处理资源，而不应该根据文件扩展名、文件内容或其他因素来尝试重新确定资源的类型。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>使用 <code>X-Content-Type-Options</code> 可以提高网站的安全性，因为它可以防止某些类型的攻击，例如 <code>MIME</code> 类型混淆攻击。这种攻击通常涉及将恶意内容伪装成合法的资源类型（如 <code>JavaScript</code> 文件），然后利用浏览器对 <code>MIME</code> 类型的错误处理来执行恶意代码，能够有效的预防 <code>XSS</code> 攻击。</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>要在你的 <code>web</code> 服务器上设置 <code>X-Content-Type-Options</code> 响应头，你需要根据你的服务器软件（如 <code>Apache、Nginx、IIS</code> 等）进行配置。下面是一些常见的服务器配置示例：</p>
<h4 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h4><p>在 Apache 中，你可以使用 mod_headers 模块来设置响应头。在你的网站配置文件中添加以下行：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute"><span class="nomarkup">Header</span></span> set X-Content-Type-Options <span class="string">"nosniff"</span></span><br></pre></td></tr></table></figure>
<h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p>在 Nginx 中，你可以在 http、server 或 location 块中添加 add_header 指令来设置响应头：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">add_header</span> X-Content-Type-Options <span class="string">"nosniff"</span>;</span><br></pre></td></tr></table></figure>
<h4 id="IIS"><a href="#IIS" class="headerlink" title="IIS"></a>IIS</h4><p>在 IIS 中，你可以使用 web.config 文件来设置响应头。在 &lt;system.webServer&gt; 部分添加以下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">httpProtocol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">customHeaders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">add</span> <span class="attr">name</span>=<span class="string">"X-Content-Type-Options"</span> <span class="attr">value</span>=<span class="string">"nosniff"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">customHeaders</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">httpProtocol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="Node-js-使用-Express"><a href="#Node-js-使用-Express" class="headerlink" title="Node.js (使用 Express)"></a>Node.js (使用 Express)</h4><p>如果你使用 <code>Node.js</code> 和 <code>Express</code> 框架，你可以在应用程序中添加中间件来设置响应头：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.setHeader(<span class="string">'X-Content-Type-Options'</span>, <span class="string">'nosniff'</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>请确保你的服务器配置正确，并且 <code>X-Content-Type-Options</code> 头部已正确设置。这样，浏览器在接收响应时就会遵守该头部的指示，从而提高应用程序的安全性。</p>

      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/">network</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/security/">security</a></li></ul>

        <a data-url="https://hankliu62.github.io/2024/03/13/security-x-content-types-options/" data-id="cluersklg000kuflox6qewc61" class="article-share-link">Share</a>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
    <article id="post-github-pages-env" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2024/03/11/github-pages-env/" class="article-date">
  <time datetime="2024-03-11T13:51:20.000Z" itemprop="datePublished">2024-03-11</time>
</h3>
    
  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content fill-content-true">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/03/11/github-pages-env/">NextJs 获取 Github Action 部署的环境变量</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <h2 id="NextJs-获取-Github-Action-部署的环境变量"><a href="#NextJs-获取-Github-Action-部署的环境变量" class="headerlink" title="NextJs 获取 Github Action 部署的环境变量"></a>NextJs 获取 Github Action 部署的环境变量</h2><h3 id="设置变量"><a href="#设置变量" class="headerlink" title="设置变量"></a>设置变量</h3><p>项目中需要某些私有密钥，不能直接暴露在仓库中，在编译<code>Next.js</code>的时候，需要将该密钥通过环境变量的形式注入到<code>Next.js</code>项目中，所以第一步，我们需要将这个密钥储存到当前仓库的<code>Settings/Secrets</code>里面，具体操作如下图所示：</p>
<p><img src="https://github.com/hankliu62/interview/assets/8088864/887a0ad5-6b4a-4977-a2cb-8c7adc5b63b6" alt="image"></p>
<h3 id="配置变量"><a href="#配置变量" class="headerlink" title="配置变量"></a>配置变量</h3><p>在<code>Next.js</code>中获取<code>GitHub Actions</code>环境变量，你可以使用<code>process.env</code>对象来访问在<code>GitHub Actions</code>中设置的环境变量。以下是一个如何在<code>Next.js</code>中获取<code>GitHub Actions</code>环境变量的例子：</p>
<p>首先，在GitHub Actions的工作流文件中设置环境变量，例如在 <code>.github/workflows/ci.yml</code>中：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">code</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node.js</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="number">14</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">Next.js</span> <span class="string">App</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">MY_ENV_VAR:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.MY_SECRET_ENV_VAR</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>MY_ENV_VAR</code>是一个环境变量，它可以是一个秘密值，通过<code>GitHub Actions</code>的秘密（secrets）功能来安全地设置。</p>
<p>然后，需要将环境变量添加到 <code>Next</code> 项目的配置文件中，在 <code>next.config.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  env: &#123;</span><br><span class="line">    MY_ENV_VAR: process.env.MY_ENV_VAR,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取变量"><a href="#获取变量" class="headerlink" title="获取变量"></a>获取变量</h3><p>然后，在Next.js的应用代码中，你可以这样获取这个环境变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pages/index.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> myEnvVar = process.env.MY_ENV_VAR;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;The environment variable is: &#123;myEnvVar || <span class="string">'undefined'</span>&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，<code>process.env.MY_ENV_VAR</code> 将会获取在 <code>GitHub Actions</code> 中设置的环境变量<code>MY_ENV_VAR</code>的值。如果环境变量存在，它将被显示在页面上；如果不存在，则会显示<code>&#39;undefined&#39;</code>。</p>

      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/blog/">blog</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/">git</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/github/">github</a></li></ul>

        <a data-url="https://hankliu62.github.io/2024/03/11/github-pages-env/" data-id="cluerskky0004uflo6l82fmvb" class="article-share-link">Share</a>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
    <article id="post-mobile-debugging-tools" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2024/03/06/mobile-debugging-tools/" class="article-date">
  <time datetime="2024-03-06T13:48:32.000Z" itemprop="datePublished">2024-03-06</time>
</h3>
    
  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content fill-content-true">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/03/06/mobile-debugging-tools/">H5 移动端调试工具汇总</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="H5-移动端调试工具汇总"><a href="#H5-移动端调试工具汇总" class="headerlink" title="H5 移动端调试工具汇总"></a>H5 移动端调试工具汇总</h2><h3 id="一、概要"><a href="#一、概要" class="headerlink" title="一、概要"></a>一、概要</h3><p>因为移动端操作系统分为 <code>iOS</code> 和 <code>Android</code> 两派，所以本文的调试技巧也会按照不同的系统来区分。寻找最合适高效的方式，才能让你事半功倍。</p>
<blockquote>
<p>文章会列举目前适合移动端调试的多种方案，快来选择你的最佳实践吧！</p>
</blockquote>
<h3 id="二、iOS-设备"><a href="#二、iOS-设备" class="headerlink" title="二、iOS 设备"></a>二、iOS 设备</h3><blockquote>
<p>Safari：iphone 调试利器，查错改样式首选，需要我们做如下设置：</p>
</blockquote>
<ul>
<li>浏览器设置：Safari - 偏好设置 - 高级 - 勾选「在菜单栏中显示开发」菜单</li>
<li>iphone 设置：设置 - Safari - 高级 - 打开 Web 检查器</li>
</ul>
<p>大功告成，这时候通过手机的 <code>Safari</code> 来打开 <code>H5</code> 页面，我们通过浏览器开发选项可以看到：</p>
<p><img src="https://github.com/hankliu62/interview/assets/8088864/fc968e7f-db70-4ae0-b9f6-08d241afb43c" alt="image"></p>
<blockquote>
<p>iOS 模拟器：不需要真机，适合调试 Webview 和 H5 有频繁交互的功能页面。</p>
</blockquote>
<p>首先下载 Xcode ，运行项目，选择模拟器 iphonex，编译后就会打开模拟器，如下：</p>
<p><img src="https://github.com/hankliu62/interview/assets/8088864/c7bf4417-1ffc-404d-a19d-5b1b215d06bb" alt="image"></p>
<p>可以看到 H5 已经在「壳子」中运行起来了，下来就可以尝试调用 Webview 的方法，和「壳子」交互了。</p>
<blockquote>
<p>具体的调试功能还是依赖浏览器的开发选项，与上无异，就不赘述了。</p>
</blockquote>
        
          <p class="article-more-link">
            <a href="/2024/03/06/mobile-debugging-tools/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/debugging/">debugging</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mobile/">mobile</a></li></ul>

        <a data-url="https://hankliu62.github.io/2024/03/06/mobile-debugging-tools/" data-id="cluerskla000dufloxupsyr85" class="article-share-link">Share</a>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
    <article id="post-webpack-plugin-mechanism" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2024/03/05/webpack-plugin-mechanism/" class="article-date">
  <time datetime="2024-03-05T12:36:12.000Z" itemprop="datePublished">2024-03-05</time>
</h3>
    
  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content fill-content-true">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/03/05/webpack-plugin-mechanism/">Webpack Plugin插件机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Webpack-Plugin插件机制"><a href="#Webpack-Plugin插件机制" class="headerlink" title="Webpack Plugin插件机制"></a>Webpack Plugin插件机制</h2><h3 id="plugin机制出现原因"><a href="#plugin机制出现原因" class="headerlink" title="plugin机制出现原因"></a>plugin机制出现原因</h3><p>前面我们已经知道了，loader机制让webpack拥有了处理除js类型文件以外的能力。</p>
<p>那如果我们需要在项目中实现<code>打包前自动清理上次打包生成的文件</code>、<code>将一些文件复制到打包目录中</code>、<code>自动生成html文件</code>、<code>将打包产物自动上传至服务器</code>、<code>将打包后代码进行压缩、拆分</code>等一系列定制化功能，此时就必须借助webpack的plugin机制去实现了。</p>
<p>没错，webpack的plugin机制让webpack有了定制化的能力。</p>
<h3 id="plugin原理"><a href="#plugin原理" class="headerlink" title="plugin原理"></a>plugin原理</h3><p>那具体如何通过plugin机制去实现这些定制化功能呢？</p>
<p>其实是webpack在打包过程中的不同阶段（配置文件读取完成后、打包开始前、打包完成后等阶段）会触发不同的钩子，我们只需要明确要实现的功能应该在哪个阶段，然后将具体实现代码注册为对应钩子的事件即可。</p>
<h3 id="webpack运行原理"><a href="#webpack运行原理" class="headerlink" title="webpack运行原理"></a>webpack运行原理</h3><p>我们在了解这些钩子之前，必须要知道webpack的运行原理。</p>
<p>这是一个简化版的webpack打包过程，当我们执行 <code>webpack build</code> 命令后，webpack会先读取配置文件，然后根据配置文件中的配置项去初始化，创建一个 <code>compiler</code> 对象，然后调用 <code>compiler</code> 对象的 <code>run</code> 方法，初始化一个 <code>compilation</code> 对象，执行 <code>compilation</code> 中的 <code>build</code> 方法进行编译，编译完成后，触发 <code>compiler</code> 对象的 <code>done</code> 钩子，完成打包。</p>
<p><img src="https://github.com/hankliu62/interview/assets/8088864/297c753f-6432-4ecc-90f3-474459b5fd82" alt="image"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步：搭建结构，读取配置参数，这里接受的是webpack.config.js中的参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">webpack</span>(<span class="params">webpackOptions</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//第二步：用配置参数对象初始化 `Compiler` 对象</span></span><br><span class="line">  <span class="keyword">const</span> compiler = <span class="keyword">new</span> Compiler(webpackOptions);</span><br><span class="line">  <span class="comment">//第三步：挂载配置文件中的插件</span></span><br><span class="line"> <span class="keyword">const</span> &#123; plugins &#125; = webpackOptions;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> plugin <span class="keyword">of</span> plugins) &#123;</span><br><span class="line">   plugin.apply(compiler);</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">return</span> compiler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Compiler其实是一个类，它是整个编译过程的大管家，而且是单例模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compiler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(webpackOptions) &#123;</span><br><span class="line">   <span class="comment">//省略</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第五步：创建compilation对象</span></span><br><span class="line">  compile(callback)&#123;</span><br><span class="line">    <span class="comment">//虽然webpack只有一个Compiler，但是每次编译都会产出一个新的Compilation，</span></span><br><span class="line">    <span class="comment">//这里主要是为了考虑到watch模式，它会在启动时先编译一次，然后监听文件变化，如果发生变化会重新开始编译</span></span><br><span class="line">    <span class="comment">//每次编译都会产出一个新的Compilation，代表每次的编译结果</span></span><br><span class="line">    <span class="keyword">let</span> compilation = <span class="keyword">new</span> Compilation(<span class="keyword">this</span>.options);</span><br><span class="line">    compilation.build(callback); <span class="comment">//执行compilation的build方法进行编译，编译成功之后执行回调</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第四步：执行`Compiler`对象的`run`方法开始执行编译</span></span><br><span class="line">  run(callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hooks.run.call(); <span class="comment">//在编译前触发run钩子执行，表示开始启动编译了</span></span><br><span class="line">    <span class="keyword">const</span> onCompiled = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 第七步：当编译成功后会触发done这个钩子执行</span></span><br><span class="line">      <span class="keyword">this</span>.hooks.done.call();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.compile(onCompiled); <span class="comment">//开始编译，成功之后调用onCompiled</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compilation</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(webpackOptions) &#123;</span><br><span class="line">    <span class="keyword">this</span>.options = webpackOptions;</span><br><span class="line">    <span class="keyword">this</span>.modules = []; <span class="comment">//本次编译所有生成出来的模块</span></span><br><span class="line">    <span class="keyword">this</span>.chunks = []; <span class="comment">//本次编译产出的所有代码块，入口模块和依赖的模块打包在一起为代码块</span></span><br><span class="line">    <span class="keyword">this</span>.assets = &#123;&#125;; <span class="comment">//本次编译产出的资源文件</span></span><br><span class="line">    <span class="keyword">this</span>.fileDependencies = []; <span class="comment">//本次打包涉及到的文件，这里主要是为了实现watch模式下监听文件的变化，文件发生变化后会重新编译</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第六步：执行compilation的build方法进行编译</span></span><br><span class="line">  build(callback) &#123;</span><br><span class="line">  <span class="comment">//这里开始做编译工作，编译成功执行callback</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 编译过程代码省略</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 编译完成后，触发callback回调</span></span><br><span class="line">  callback()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
          <p class="article-more-link">
            <a href="/2024/03/05/webpack-plugin-mechanism/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/">webpack</a></li></ul>

        <a data-url="https://hankliu62.github.io/2024/03/05/webpack-plugin-mechanism/" data-id="cluersklw000wuflootmitt4i" class="article-share-link">Share</a>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/04/02/security-anti-reptile/">Web安全之静态内容防爬虫</a>
          </li>
        
          <li>
            <a href="/2024/03/31/security-sql-injection/">Web安全之 SQL 注入</a>
          </li>
        
          <li>
            <a href="/2024/03/30/thread-loader/">thread-loader</a>
          </li>
        
          <li>
            <a href="/2024/03/29/vitepress-blog-guide/">使用VitePress搭建个人博客</a>
          </li>
        
          <li>
            <a href="/2024/03/27/security-csrf/">Web安全之 CSRF 攻击</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/blog/">blog</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/csrf/">csrf</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debugging/">debugging</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/">github</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github-pages/">github pages</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/interview/">interview</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/loader/">loader</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mobile/">mobile</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/">network</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reptile/">reptile</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/security/">security</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/">shell</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/">sql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ubuntu/">ubuntu</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vitepress/">vitepress</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/">webpack</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/weinre/">weinre</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xss/">xss</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">四月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">三月 2024</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">二月 2024</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2024 HankLiu, Inc. All rights reserved.<br>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">文章</a>
  
    <a href="/toolbox-frontend" class="mobile-nav-link">小工具</a>
  
    <a href="/resume" class="mobile-nav-link">小简介</a>
  
  <a href="#search" class="mobile-nav-link st-search-show-outputs">Search</a>
</nav>
  

<!-- totop start -->
<div id="totop">
	<a title="To Top"></a>
</div>
<!-- totop end -->

<!-- swiftype search start -->

<!-- swiftype search end -->



<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/lrsjng.jquery-qrcode/0.12.0/jquery.qrcode.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

</div>
</body>
</html>
