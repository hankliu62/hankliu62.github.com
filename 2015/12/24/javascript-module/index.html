
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  
  <title>菜鸟学习Javascript模块化 | hankliu小博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一、模块化的定义模块化是一种处理复杂系统分解为更好的可管理模块的方式。它可以通过在不同组件设定不同的功能，把一个问题分解成多个小的独立、互相作用的组件，来处理复杂、大型的软件。简单点来讲就是以功能为单位，然后通过不同功能的组合来实现一个系统，模块化的主要的目的就是为了减少依赖，减少耦合，提交代码的复用性，最终提交开发的效率。为了这个目的，所以我们必须将耦合密度的功能定义在一个模块中，并且在每个模块">
<meta name="keywords" content="Javascript,模块化">
<meta property="og:type" content="article">
<meta property="og:title" content="菜鸟学习Javascript模块化">
<meta property="og:url" content="http://yoursite.com/2015/12/24/javascript-module/index.html">
<meta property="og:site_name" content="hankliu小博客">
<meta property="og:description" content="一、模块化的定义模块化是一种处理复杂系统分解为更好的可管理模块的方式。它可以通过在不同组件设定不同的功能，把一个问题分解成多个小的独立、互相作用的组件，来处理复杂、大型的软件。简单点来讲就是以功能为单位，然后通过不同功能的组合来实现一个系统，模块化的主要的目的就是为了减少依赖，减少耦合，提交代码的复用性，最终提交开发的效率。为了这个目的，所以我们必须将耦合密度的功能定义在一个模块中，并且在每个模块">
<meta property="og:locale" content="zh-cn">
<meta property="og:updated_time" content="2017-09-09T00:45:31.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="菜鸟学习Javascript模块化">
<meta name="twitter:description" content="一、模块化的定义模块化是一种处理复杂系统分解为更好的可管理模块的方式。它可以通过在不同组件设定不同的功能，把一个问题分解成多个小的独立、互相作用的组件，来处理复杂、大型的软件。简单点来讲就是以功能为单位，然后通过不同功能的组合来实现一个系统，模块化的主要的目的就是为了减少依赖，减少耦合，提交代码的复用性，最终提交开发的效率。为了这个目的，所以我们必须将耦合密度的功能定义在一个模块中，并且在每个模块">
  
    <link rel="alternative" href="/atom.xml" title="hankliu小博客" type="application/atom+xml">
  
  
    <link rel="icon" href="http://oiq00n80p.bkt.clouddn.com/favicons_2_16.png" sizes="16x16">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
  

</head>

<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <nav id="upper-nav" class="inner">
      <a id="main-nav-toggle" class="nav-icon"></a>
      <div class="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        
          <a id="nav-github" class="nav-icon" href="https://github.com/biluo62"></a>
        
      </div>
    </nav>
    <div id="header-title">
      
        <h1 id="blog-title-wrap">
          <a href="/" id="blog-title">hankliu</a>
        </h1>
      
      
        <h5 class="blog-subtitle-wrap">我们在梦里走过许多路，醒来后却发现自己还在床上。</h5>
      
    </div>
    <div id="contenedor">
      <ul class="cube">
        <li class="cara"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="100" width="100" viewBox="-50 -50 200 200">
          <circle cx="50" cy="50" r="45" stroke-width="5" stroke="black" stroke-opacity="0.5" fill-opacity="0"></circle>
          <rect x="47.5" y="27.5" width="5" height="25" rx="2.5" ry="2.5" fill="black" fill-opacity="0.5" transform="rotate(330 50 50)"></rect>
          <rect x="48.5" y="16.5" width="3" height="35" rx="1.5" ry="1.5" fill="black" fill-opacity="0.5"></rect>
        </svg></li>
        <li class="cara">L</li>
        <li class="cara">X</li>
        <li class="cara">P</li>
        <li class="cara">C</li>
        <li class="cara">Y</li>
      </ul>
    </div>
    <nav id="main-nav">
      
        <a class="main-nav-link" href="/">Home</a>
      
        <a class="main-nav-link" href="/archives">Archives</a>
      
        <a class="main-nav-link" href="/about">About</a>
      
      <a class="main-nav-link st-search-show-outputs">Search</a>
    </nav>
  </div>
</header>

    <div class="outer">
      <section id="main"><article id="post-javascript-module" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2015/12/24/javascript-module/" class="article-date">
  <time datetime="2015-12-24T10:55:37.000Z" itemprop="datePublished">2015-12-24</time>
</h3>
    
  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      菜鸟学习Javascript模块化
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <h2 id="一、模块化的定义"><a href="#一、模块化的定义" class="headerlink" title="一、模块化的定义"></a>一、模块化的定义</h2><p>模块化是一种处理复杂系统分解为更好的可管理模块的方式。它可以通过在不同组件设定不同的功能，把一个问题分解成多个小的独立、互相作用的组件，来处理复杂、大型的软件。简单点来讲就是以功能为单位，然后通过不同功能的组合来实现一个系统，模块化的主要的目的就是为了减少依赖，减少耦合，提交代码的复用性，最终提交开发的效率。为了这个目的，所以我们必须将耦合密度的功能定义在一个模块中，并且在每个模块中第一一些入口和出口，以方便模块的组合和交互。</p>
<h2 id="二、Javascript的模块化"><a href="#二、Javascript的模块化" class="headerlink" title="二、Javascript的模块化"></a>二、Javascript的模块化</h2><p>随着网站逐渐变成”互联网应用程序”，嵌入网页的Javascript代码越来越庞大，越来越复杂。Javascript模块化编程，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。</p>
<h2 id="三、Javascript模块化的发展"><a href="#三、Javascript模块化的发展" class="headerlink" title="三、Javascript模块化的发展"></a>三、Javascript模块化的发展</h2><h3 id="1、原始写法"><a href="#1、原始写法" class="headerlink" title="1、原始写法"></a>1、原始写法</h3><p>模块就是实现特定功能的一组方法。,不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　<span class="comment">//...</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　<span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>缺点：”污染”了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。</p>
<h3 id="2、对象写法"><a href="#2、对象写法" class="headerlink" title="2、对象写法"></a>2、对象写法</h3><p>为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面。使用的时候，就是调用这个对象的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> module1 = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;</div><div class="line">　　_count : <span class="number">0</span>,</div><div class="line">　　m1 : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">　　　 <span class="comment">//...</span></div><div class="line">　　&#125;,</div><div class="line">　　m2 : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">　　　　<span class="comment">//...</span></div><div class="line">　　&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>缺点：写法会暴露所有模块成员，内部状态可以被外部改写</p>
<h3 id="3、立即执行函数写法"><a href="#3、立即执行函数写法" class="headerlink" title="3、立即执行函数写法"></a>3、立即执行函数写法</h3><p>使用”立即执行函数”，可以达到不暴露私有成员的目的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　<span class="keyword">var</span> _count = <span class="number">0</span>;</div><div class="line">　　<span class="keyword">var</span> m1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　<span class="comment">//...</span></div><div class="line">　　&#125;;</div><div class="line">　　<span class="keyword">var</span> m2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　<span class="comment">//...</span></div><div class="line">　　&#125;;</div><div class="line">　　<span class="keyword">return</span> &#123;</div><div class="line">　　　　m1 : m1,</div><div class="line">　　　　m2 : m2</div><div class="line">　　&#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>module1就是Javascript模块的基本写法。下面，再对这种写法进行加工。</p>
<h3 id="4、放大模式"><a href="#4、放大模式" class="headerlink" title="4、放大模式"></a>4、放大模式</h3><p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用”放大模式”。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> (<span class="params">mod</span>)</span>&#123;</div><div class="line">　　mod.m3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">　　　　<span class="comment">//...</span></div><div class="line">　　&#125;;</div><div class="line">　　<span class="keyword">return</span> mod;</div><div class="line">&#125;)(module1);</div></pre></td></tr></table></figure></p>
<p>上面的代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。</p>
<h3 id="5、宽放大模式"><a href="#5、宽放大模式" class="headerlink" title="5、宽放大模式"></a>5、宽放大模式</h3><p>在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上一节的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> module1 = ( <span class="function"><span class="keyword">function</span> (<span class="params">mod</span>)</span>&#123;</div><div class="line">　　<span class="comment">//...</span></div><div class="line">　　<span class="keyword">return</span> mod;</div><div class="line">&#125;)(<span class="built_in">window</span>.module1 || &#123;&#125;);</div></pre></td></tr></table></figure></p>
<p>与”放大模式”相比，＂宽放大模式＂就是”立即执行函数”的参数可以是空对象。</p>
<h3 id="6、输入全局变量"><a href="#6、输入全局变量" class="headerlink" title="6、输入全局变量"></a>6、输入全局变量</h3><p>独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。<br>为了在模块内部调用全局变量，必须显式地将其他变量输入模块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> (<span class="params">$, YAHOO</span>) </span>&#123;</div><div class="line">　　<span class="comment">//...</span></div><div class="line">&#125;)(jQuery, YAHOO);</div></pre></td></tr></table></figure>
<p>上面的module1模块需要使用jQuery库和YUI库，就把这两个库（其实是两个模块）当作参数输入module1。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。</p>
<h2 id="四、模块的规范"><a href="#四、模块的规范" class="headerlink" title="四、模块的规范"></a>四、模块的规范</h2><p>先想一想，为什么模块很重要？<br>因为有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。<br>但是，这样做有一个前提，那就是大家必须以同样的方式编写模块，否则你有你的写法，我有我的写法，岂不是乱了套！考虑到Javascript模块现在还没有官方规范，这一点就更重要了。<br>目前，通行的Javascript模块规范共有两种：CommonJS和AMD。我主要介绍AMD，但是要先从CommonJS讲起。</p>
<h3 id="1、CommonJS"><a href="#1、CommonJS" class="headerlink" title="1、CommonJS"></a>1、CommonJS</h3><p>2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程。</p>
<p>这标志”Javascript模块化编程”正式诞生。因为老实说，在浏览器环境下，没有模块也不是特别大的问题，毕竟网页程序的复杂性有限；但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。<br>node.js的模块系统，就是参照CommonJS规范实现的。在CommonJS中，有一个全局性方法require()，用于加载模块。假定有一个数学模块math.js，就可以像下面这样加载。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);</div></pre></td></tr></table></figure></p>
<p>然后，就可以调用模块提供的方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);</div><div class="line">math.add(<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// 5</span></div></pre></td></tr></table></figure></p>
<h3 id="2、浏览器环境"><a href="#2、浏览器环境" class="headerlink" title="2、浏览器环境"></a>2、浏览器环境</h3><p>有了服务器端模块以后，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。<br>但是，由于一个重大的局限，使得CommonJS规范不适用于浏览器环境。还是上一节的代码，如果在浏览器中运行，会有一个很大的问题，你能看出来吗？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);</div><div class="line">math.add(<span class="number">2</span>, <span class="number">3</span>);</div></pre></td></tr></table></figure>
<p>第二行math.add(2, 3)，在第一行require(‘math’)之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。<br>这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。<br>因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。</p>
<h3 id="3、AMD"><a href="#3、AMD" class="headerlink" title="3、AMD"></a>3、AMD</h3><p>AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。<br>AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="built_in">module</span>], callback);</div></pre></td></tr></table></figure></p>
<p>第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成AMD形式，就是下面这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">math</span>) </span>&#123;</div><div class="line">　　math.add(<span class="number">2</span>, <span class="number">3</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。<br>目前，主要有两个Javascript库实现了AMD规范：require.js和curl.js。</p>
<h2 id="五、require-js"><a href="#五、require-js" class="headerlink" title="五、require.js"></a>五、require.js</h2><h3 id="1、为什么要用require-js"><a href="#1、为什么要用require-js" class="headerlink" title="1、为什么要用require.js"></a>1、为什么要用require.js</h3><p>最早的时候，所有Javascript代码都写在一个文件里面，只要加载这一个文件就够了。后来，代码越来越多，一个文件不够了，必须分成多个文件，依次加载。下面的网页代码，相信很多人都见过。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">"1.js"</span>&gt;&lt;/script&gt;</div><div class="line">&lt;script src=<span class="string">"2.js"</span>&gt;&lt;/script&gt;</div><div class="line">&lt;script src=<span class="string">"3.js"</span>&gt;&lt;/script&gt;</div><div class="line">&lt;script src=<span class="string">"4.js"</span>&gt;&lt;/script&gt;</div><div class="line">&lt;script src=<span class="string">"5.js"</span>&gt;&lt;/script&gt;</div><div class="line">&lt;script src=<span class="string">"6.js"</span>&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>这段代码依次加载多个js文件。<br>这样的写法有很大的缺点。首先，加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长；其次，由于js文件之间存在依赖关系，因此必须严格保证加载顺序（比如上例的1.js要在2.js的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。<br>require.js的诞生，就是为了解决这两个问题：</p>
<ul>
<li>实现js文件的异步加载，避免网页失去响应</li>
<li>管理模块之间的依赖性，便于代码的编写和维护</li>
</ul>
<h3 id="2、require-js的加载"><a href="#2、require-js的加载" class="headerlink" title="2、require.js的加载"></a>2、require.js的加载</h3><p>使用require.js的第一步，是先去官方网站下载最新版本。<br>下载后，假定把它放在js子目录下面，就可以加载了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">"js/require.js"</span>&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>加载这个文件，也可能造成网页失去响应。解决办法有两个，一个是把它放在网页底部加载，另一个是写成下面这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">"js/require.js"</span> defer <span class="keyword">async</span>=<span class="string">"true"</span>&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上。<br>加载require.js以后，下一步就要加载我们自己的代码了。假定我们自己的代码文件是main.js，也放在js目录下面。那么，只需要写成下面这样就行了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">"js/require.js"</span> data-main=<span class="string">"js/main"</span> defer <span class="keyword">async</span>=<span class="string">"true"</span>&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>data-main属性的作用是，指定网页程序的主模块。在上例中，就是js目录下面的main.js，这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。</p>
<h3 id="3、主模块的写法"><a href="#3、主模块的写法" class="headerlink" title="3、主模块的写法"></a>3、主模块的写法</h3><p>上一节的main.js，我把它称为”主模块”，意思是整个网页的入口代码。它有点像C语言的main()函数，所有代码都从这儿开始运行。<br>下面就来看，怎么写main.js。<br>如果我们的代码不依赖任何其他模块，那么可以直接写入javascript代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.js</span></div><div class="line">alert(<span class="string">"加载成功！"</span>);</div></pre></td></tr></table></figure></p>
<p>但这样的话，就没必要使用require.js了。真正常见的情况是，主模块依赖于其他模块，这时就要使用AMD规范定义的的require()函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="built_in">require</span>([<span class="string">'moduleA'</span>, <span class="string">'moduleB'</span>, <span class="string">'moduleC'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">moduleA, moduleB, moduleC</span>)</span>&#123;</div><div class="line">　　<span class="comment">// some code here</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>require()函数接受两个参数。第一个参数是一个数组，表示所依赖的模块，上例就是[‘moduleA’, ‘moduleB’, ‘moduleC’]，即主模块依赖这三个模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。<br>require()异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。<br>下面，我们看一个实际的例子。<br>假定主模块依赖jquery、underscore和backbone这三个模块，main.js就可以这样写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'jquery'</span>, <span class="string">'underscore'</span>, <span class="string">'backbone'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">$, _, Backbone</span>)</span>&#123;</div><div class="line">　　<span class="comment">// some code here</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>require.js会先加载jQuery、underscore和backbone，然后再运行回调函数。主模块的代码就写在回调函数中。</p>
<h3 id="4、模块的加载"><a href="#4、模块的加载" class="headerlink" title="4、模块的加载"></a>4、模块的加载</h3><p>上一节最后的示例中，主模块的依赖模块是[‘jquery’, ‘underscore’, ‘backbone’]。默认情况下，require.js假定这三个模块与main.js在同一个目录，文件名分别为jquery.js，underscore.js和backbone.js，然后自动加载。<br>使用require.config()方法，我们可以对模块的加载行为进行自定义。require.config()就写在主模块（main.js）的头部。参数就是一个对象，这个对象的paths属性指定各个模块的加载路径。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">　 paths: &#123;</div><div class="line">　　　　<span class="string">"jquery"</span>: <span class="string">"jquery.min"</span>,</div><div class="line">　　　　<span class="string">"underscore"</span>: <span class="string">"underscore.min"</span>,</div><div class="line">　　　　<span class="string">"backbone"</span>: <span class="string">"backbone.min"</span></div><div class="line">　　&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面的代码给出了三个模块的文件名，路径默认与main.js在同一个目录（js子目录）。如果这些模块在其他目录，比如js/lib目录，则有两种写法。一种是逐一指定路径。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">　　paths: &#123;</div><div class="line">　　　　<span class="string">"jquery"</span>: <span class="string">"lib/jquery.min"</span>,</div><div class="line">　　　　<span class="string">"underscore"</span>: <span class="string">"lib/underscore.min"</span>,</div><div class="line">　　　　<span class="string">"backbone"</span>: <span class="string">"lib/backbone.min"</span></div><div class="line">　　&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>另一种则是直接改变基目录（baseUrl）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">　　baseUrl: <span class="string">"js/lib"</span>,</div><div class="line">　　paths: &#123;</div><div class="line">　　　　<span class="string">"jquery"</span>: <span class="string">"jquery.min"</span>,</div><div class="line">　　　　<span class="string">"underscore"</span>: <span class="string">"underscore.min"</span>,</div><div class="line">　　　　<span class="string">"backbone"</span>: <span class="string">"backbone.min"</span></div><div class="line">　　&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>require.js要求，每个模块是一个单独的js文件。这样的话，如果加载多个模块，就会发出多次HTTP请求，会影响网页的加载速度。因此，require.js提供了一个优化工具，当模块部署完毕以后，可以用这个工具将多个模块合并在一个文件中，减少HTTP请求数。</p>
<h3 id="5、AMD模块的写法"><a href="#5、AMD模块的写法" class="headerlink" title="5、AMD模块的写法"></a>5、AMD模块的写法</h3><p>require.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写。<br>具体来说，就是模块必须采用特定的define()函数来定义。如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。<br>假定现在有一个math.js文件，它定义了一个math模块。那么，math.js就要这样写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// math.js</span></div><div class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">　　<span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>)</span>&#123;</div><div class="line">　　　　<span class="keyword">return</span> x+y;</div><div class="line">　　&#125;;</div><div class="line">　　<span class="keyword">return</span> &#123;</div><div class="line">　　　　add: add</div><div class="line">　　&#125;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 加载方式</span></div><div class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">math</span>)</span>&#123;</div><div class="line">　　alert(math.add(<span class="number">1</span>,<span class="number">1</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>如果这个模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">define([<span class="string">'myLib'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">myLib</span>)</span>&#123;</div><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　myLib.doSomething();</div><div class="line">　　&#125;</div><div class="line">　　<span class="keyword">return</span> &#123;</div><div class="line">　　　　foo : foo</div><div class="line">　　&#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当require()函数加载上面这个模块的时候，就会先加载myLib.js文件。</p>
<h3 id="6、加载非规范的模块"><a href="#6、加载非规范的模块" class="headerlink" title="6、加载非规范的模块"></a>6、加载非规范的模块</h3><p>理论上，require.js加载的模块，必须是按照AMD规范、用define()函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合。那么，require.js是否能够加载非规范的模块呢？<br>回答是可以的。<br>这样的模块在用require()加载之前，要先用require.config()方法，定义它们的一些特征。<br>举例来说，underscore和backbone这两个库，都没有采用AMD规范编写。如果要加载它们的话，必须先定义它们的特征。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">　　shim: &#123;</div><div class="line">　　　　<span class="string">'underscore'</span>:&#123;</div><div class="line">　　　　　　exports: <span class="string">'_'</span></div><div class="line">　　　　&#125;,</div><div class="line">　　　　<span class="string">'backbone'</span>: &#123;</div><div class="line">　　　　　　deps: [<span class="string">'underscore'</span>, <span class="string">'jquery'</span>],</div><div class="line">　　　　　　exports: <span class="string">'Backbone'</span></div><div class="line">　　　　&#125;</div><div class="line">　　&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>require.config()接受一个配置对象，这个对象除了有前面说过的paths属性之外，还有一个shim属性，专门用来配置不兼容的模块。具体来说，每个模块要定义（1）exports值（输出的变量名），表明这个模块外部调用时的名称；（2）deps数组，表明该模块的依赖性。<br>比如，jQuery的插件可以这样定义：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">shim: &#123;</div><div class="line">　　<span class="string">'jquery.scroll'</span>: &#123;</div><div class="line">　　　　deps: [<span class="string">'jquery'</span>],</div><div class="line">　　　　exports: <span class="string">'jQuery.fn.scroll'</span></div><div class="line">　　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="7、require-js插件"><a href="#7、require-js插件" class="headerlink" title="7、require.js插件"></a>7、require.js插件</h3><p>require.js还提供一系列插件，实现一些特定的功能。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// domready插件，可以让回调函数在页面DOM结构加载完成后再运行。</span></div><div class="line"><span class="built_in">require</span>([<span class="string">'domready!'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">doc</span>)</span>&#123;</div><div class="line">　　<span class="comment">// called once the DOM is ready</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// text和image插件，则是允许require.js加载文本和图片文件。</span></div><div class="line">define([<span class="string">'text!review.txt'</span>, <span class="string">'image!cat.jpg'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">review,cat</span>)</span>&#123;</div><div class="line">　　<span class="built_in">console</span>.log(review);</div><div class="line">　　<span class="built_in">document</span>.body.appendChild(cat);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//类似的插件还有json和mdown，用于加载json文件和markdown文件。</span></div></pre></td></tr></table></figure></p>
<h2 id="六、自己的看法"><a href="#六、自己的看法" class="headerlink" title="六、自己的看法"></a>六、自己的看法</h2><p>&ensp;&ensp;&ensp;&ensp;作为一个前端模块化的菜鸟，看了上面对Javascript模块化的定义，发展以及规范的一些描述，使我对JavaScript模块化有了一定的了解，RequireJS 是一个很优秀的模块加载器，让JavaScript的模块化开发更加简洁，定义了一个作用域来避免全局名称空间污染，并且通过RequireJs的语法，使得模块与模块之间的依赖关系非常明显，同时，它提倡提前执行依赖，通过模块的异步加载，加快了模块的加载速度，虽然异步加载的顺序可能不一定的，通过依赖关系来加载的模块是可确定的，提前执行依赖，有好处也有坏处，好处就是具有良好的用户体检，在一开始加载完依赖后，无需再加载依赖，用户操作的反应速度也会更快，但是坏处就是肯能会存在带宽的浪费，因为提前加载依赖可能在之后的代码运行中不一定会用到。个人觉得有时候为了更好的用户体验，一定的带宽的浪费是可取的。RequireJS特别突出的优点就是，它有着详细文档，丰富案例和活跃的社区论坛，而且使用RequireJS的前端大牛也非常多，当我们存在任何疑问的时候，我们可以通过文档或者咨询前端大牛得到帮助。RequireJS的优势在于异步加载，加快模块加载速度，同时它的坑爹之处也在于它的异步加载，异步加载会导致模块加载顺序不是确定的，如果开发者不注意的话，会造成一些意想不到的结果。</p>
<p>&ensp;&ensp;&ensp;&ensp;聊完了RequireJS，我们再来聊一聊另一种规范的模块加载器：SeaJS，SeaJS 是遵循的 CMD （通用模块定义）规范的模块加载器，CMD规范明确的给定了基本的写法和交互规则，还规定了每一个模块都是一个文件，具体模块的都是使用define关键字来定义的，并且使用exports（对象）用来向外提供模块接口，同时通过require关键字来获取其他模块提供的接口，由此可以看出，CMD规范与Node.js的Modules规范非常相似。SeaJs就是CMD规范的一个明显的代表，通用API只有define, require, require.async, exports, module.exports这五个，所以学习起来非常的快速和方便。SeaJs的代码书写非常简单，SeaJs推崇的是依赖靠近的原则，所以其依赖关系清晰明了，能够提高JavaScript代码的可读性，这是与RequireJS一个很明显的不同点，RequireJS推崇的是依赖前置，RequireJS将模块依赖的关系定义在模块的头部，另一个不同的地方在于，RequireJS对于依赖的模块是提前执行的（RequireJS 2.0后，提供了延迟执行的写法），而SeaJs延迟执行的，SeaJs提倡的是as lazy as possible。提前执行有好处也有坏处，在上面也提到过，所以提前执行的优点还是要看具体运行的环境的。</p>
<p>&ensp;&ensp;&ensp;&ensp;2015年6月17日，ECMAScript 6发布正式版本，ES6在ES5的基础上做了很大的改动，好像听到了前端开发人员对Javascript模块化的强烈呼唤，所以ES6增添了许多必要的特性，比如说：模块和类，由于以前JavaScript没有内置方法来支持模块化，开发者使用模块化的方式并不统一，所以ES6模块化的目标是创建一种 CommonJS 和 AMD 使用者都乐意接受的方式，语法与CommonJS类似，简洁明了，倾向于单一的接口，同时也类似AMD，支持模块的异步加载和配置模块加载，我觉得ES6的好处就是，首先，不需要任何的第三方库可以实现JavaScript的模块化，节约带宽和内存，其次，就是其语法非常简单，一般来说，我们使用export关键词导出对象，这个关键字可以无限次使用；使用import关键字将其它模块导入某一模块中，它可用来导入任意数量的模块。一般情况下，只需要上述两个关键字就实现了模块化。总的来说使用ES6来实现模块化相对于上述两种方案更加方便简洁，我们就静静的等待浏览器对ES6的支持吧，到时候ES6一定会大放光彩。</p>
<p>文章出处：<a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2012/10/javascript_module.html</a></p>

      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javascript/">Javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/模块化/">模块化</a></li></ul>

        <a data-url="http://yoursite.com/2015/12/24/javascript-module/" data-id="cj7crw57a0002mxcgpddcbps6" class="article-share-link">Share</a>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/12/24/javascript-common-function/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Javascript语法糖
        
      </div>
    </a>
  
  
    <a href="/2015/12/24/ubuntu-netstat/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">ubuntu查看和关闭端口</div>
    </a>
  
</nav>

  
</article>


</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/09/09/hexo-github-blog-guide/">MAC搭建个人博客hexo+github详细完整步骤</a>
          </li>
        
          <li>
            <a href="/2015/12/24/javascript-common-function/">Javascript语法糖</a>
          </li>
        
          <li>
            <a href="/2015/12/24/javascript-module/">菜鸟学习Javascript模块化</a>
          </li>
        
          <li>
            <a href="/2015/12/24/ubuntu-netstat/">ubuntu查看和关闭端口</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/">Javascript</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PID/">PID</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ubuntu/">ubuntu</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模块化/">模块化</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 hankliu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/sun11/hexo-theme-paperbox" target="_blank">Paperbox</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
  <a href="#search" class="mobile-nav-link st-search-show-outputs">Search</a>
</nav>
  

<!-- totop start -->
<div id="totop">
	<a title="To Top"></a>
</div>
<!-- totop end -->

<!-- swiftype search start -->

<!-- swiftype search end -->



<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/lrsjng.jquery-qrcode/0.12.0/jquery.qrcode.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

</div>
</body>
</html>
