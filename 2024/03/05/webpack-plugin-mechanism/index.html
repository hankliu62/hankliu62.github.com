
<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  
  <title>Webpack Plugin插件机制 | HankLiu的博客小屋</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Webpack Plugin插件机制plugin机制出现原因前面我们已经知道了，loader机制让webpack拥有了处理除js类型文件以外的能力。 那如果我们需要在项目中实现打包前自动清理上次打包生成的文件、将一些文件复制到打包目录中、自动生成html文件、将打包产物自动上传至服务器、将打包后代码进行压缩、拆分等一系列定制化功能，此时就必须借助webpack的plugin机制去实现了。 没错，w">
<meta name="keywords" content="javascript,webpack">
<meta property="og:type" content="article">
<meta property="og:title" content="Webpack Plugin插件机制">
<meta property="og:url" content="https://hankliu62.github.io/2024/03/05/webpack-plugin-mechanism/index.html">
<meta property="og:site_name" content="HankLiu的博客小屋">
<meta property="og:description" content="Webpack Plugin插件机制plugin机制出现原因前面我们已经知道了，loader机制让webpack拥有了处理除js类型文件以外的能力。 那如果我们需要在项目中实现打包前自动清理上次打包生成的文件、将一些文件复制到打包目录中、自动生成html文件、将打包产物自动上传至服务器、将打包后代码进行压缩、拆分等一系列定制化功能，此时就必须借助webpack的plugin机制去实现了。 没错，w">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="https://github.com/hankliu62/interview/assets/8088864/297c753f-6432-4ecc-90f3-474459b5fd82">
<meta property="og:image" content="https://github.com/hankliu62/interview/assets/8088864/dec8ff7b-7561-4d15-b96f-54c6bde1a4ab">
<meta property="og:image" content="https://github.com/hankliu62/interview/assets/8088864/ae6043a5-e389-4c3c-beb7-d56e30bdf1f5">
<meta property="og:image" content="https://github.com/hankliu62/interview/assets/8088864/8e03fb89-5b75-4100-aeb9-bd35fa261143">
<meta property="og:image" content="https://github.com/hankliu62/interview/assets/8088864/c4944703-5add-4ca1-8cb8-34e867b1f2b7">
<meta property="og:updated_time" content="2024-03-25T02:40:45.902Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Webpack Plugin插件机制">
<meta name="twitter:description" content="Webpack Plugin插件机制plugin机制出现原因前面我们已经知道了，loader机制让webpack拥有了处理除js类型文件以外的能力。 那如果我们需要在项目中实现打包前自动清理上次打包生成的文件、将一些文件复制到打包目录中、自动生成html文件、将打包产物自动上传至服务器、将打包后代码进行压缩、拆分等一系列定制化功能，此时就必须借助webpack的plugin机制去实现了。 没错，w">
<meta name="twitter:image" content="https://github.com/hankliu62/interview/assets/8088864/297c753f-6432-4ecc-90f3-474459b5fd82">
  
  
    <link rel="icon" href="/img/favicon.ico" sizes="16x16">
  
  <link rel="stylesheet" href="/css/style.css?t=1">
  
    <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
  

</head>
</html>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner">
    <div id="banner-mask"></div>
  </div>
  <div id="header-outer" class="outer">
    <nav id="upper-nav" class="inner">
      <a id="main-nav-toggle" class="nav-icon"></a>
      <div class="sub-nav">
        
        
          <a id="nav-github" class="nav-icon" href="https://github.com/hankliu62"></a>
        
      </div>
    </nav>
    <div id="header-title">
      
        <h1 id="blog-title-wrap">
          <a href="/" id="blog-title">HankLiu的博客小屋</a>
        </h1>
      
      
        <h5 class="blog-subtitle-wrap">努力去听风的声音，不必在意风的方向。</h5>
      
    </div>
    <div id="contenedor">
      <ul class="cube">
        <li class="cara"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="100" width="100" viewBox="-50 -50 200 200">
          <circle cx="50" cy="50" r="45" stroke-width="5" stroke="black" stroke-opacity="0.5" fill-opacity="0"></circle>
          <rect id="clockwise" x="47.5" y="27.5" width="5" height="25" rx="2.5" ry="2.5" fill="black" fill-opacity="0.5" transform="rotate(330 50 50)"></rect>
          <rect id="minute" x="48.5" y="16.5" width="3" height="35" rx="1.5" ry="1.5" fill="black" fill-opacity="0.5"></rect>
        </svg></li>
        <li class="cara">P</li>
        <li class="cara">X</li>
        <li class="cara">L</li>
        <li class="cara">C</li>
        <li class="cara">Y</li>
      </ul>
    </div>
    <nav id="main-nav">
      
        <a class="main-nav-link" href="/">主页</a>
      
        <a class="main-nav-link" href="/archives">文章</a>
      
        <a class="main-nav-link" href="/toolbox-frontend">小工具</a>
      
        <a class="main-nav-link" href="/resume">小简介</a>
      
    </nav>
  </div>
</header>

    <div class="outer">
      <section id="main"><article id="post-webpack-plugin-mechanism" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2024/03/05/webpack-plugin-mechanism/" class="article-date">
  <time datetime="2024-03-05T12:36:12.000Z" itemprop="datePublished">2024-03-05</time>
</h3>
    
  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content fill-content-false">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Webpack Plugin插件机制
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <h2 id="Webpack-Plugin插件机制"><a href="#Webpack-Plugin插件机制" class="headerlink" title="Webpack Plugin插件机制"></a>Webpack Plugin插件机制</h2><h3 id="plugin机制出现原因"><a href="#plugin机制出现原因" class="headerlink" title="plugin机制出现原因"></a>plugin机制出现原因</h3><p>前面我们已经知道了，loader机制让webpack拥有了处理除js类型文件以外的能力。</p>
<p>那如果我们需要在项目中实现<code>打包前自动清理上次打包生成的文件</code>、<code>将一些文件复制到打包目录中</code>、<code>自动生成html文件</code>、<code>将打包产物自动上传至服务器</code>、<code>将打包后代码进行压缩、拆分</code>等一系列定制化功能，此时就必须借助webpack的plugin机制去实现了。</p>
<p>没错，webpack的plugin机制让webpack有了定制化的能力。</p>
<h3 id="plugin原理"><a href="#plugin原理" class="headerlink" title="plugin原理"></a>plugin原理</h3><p>那具体如何通过plugin机制去实现这些定制化功能呢？</p>
<p>其实是webpack在打包过程中的不同阶段（配置文件读取完成后、打包开始前、打包完成后等阶段）会触发不同的钩子，我们只需要明确要实现的功能应该在哪个阶段，然后将具体实现代码注册为对应钩子的事件即可。</p>
<h3 id="webpack运行原理"><a href="#webpack运行原理" class="headerlink" title="webpack运行原理"></a>webpack运行原理</h3><p>我们在了解这些钩子之前，必须要知道webpack的运行原理。</p>
<p>这是一个简化版的webpack打包过程，当我们执行 <code>webpack build</code> 命令后，webpack会先读取配置文件，然后根据配置文件中的配置项去初始化，创建一个 <code>compiler</code> 对象，然后调用 <code>compiler</code> 对象的 <code>run</code> 方法，初始化一个 <code>compilation</code> 对象，执行 <code>compilation</code> 中的 <code>build</code> 方法进行编译，编译完成后，触发 <code>compiler</code> 对象的 <code>done</code> 钩子，完成打包。</p>
<p><img src="https://github.com/hankliu62/interview/assets/8088864/297c753f-6432-4ecc-90f3-474459b5fd82" alt="image"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步：搭建结构，读取配置参数，这里接受的是webpack.config.js中的参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">webpack</span>(<span class="params">webpackOptions</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//第二步：用配置参数对象初始化 `Compiler` 对象</span></span><br><span class="line">  <span class="keyword">const</span> compiler = <span class="keyword">new</span> Compiler(webpackOptions);</span><br><span class="line">  <span class="comment">//第三步：挂载配置文件中的插件</span></span><br><span class="line"> <span class="keyword">const</span> &#123; plugins &#125; = webpackOptions;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> plugin <span class="keyword">of</span> plugins) &#123;</span><br><span class="line">   plugin.apply(compiler);</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">return</span> compiler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Compiler其实是一个类，它是整个编译过程的大管家，而且是单例模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compiler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(webpackOptions) &#123;</span><br><span class="line">   <span class="comment">//省略</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第五步：创建compilation对象</span></span><br><span class="line">  compile(callback)&#123;</span><br><span class="line">    <span class="comment">//虽然webpack只有一个Compiler，但是每次编译都会产出一个新的Compilation，</span></span><br><span class="line">    <span class="comment">//这里主要是为了考虑到watch模式，它会在启动时先编译一次，然后监听文件变化，如果发生变化会重新开始编译</span></span><br><span class="line">    <span class="comment">//每次编译都会产出一个新的Compilation，代表每次的编译结果</span></span><br><span class="line">    <span class="keyword">let</span> compilation = <span class="keyword">new</span> Compilation(<span class="keyword">this</span>.options);</span><br><span class="line">    compilation.build(callback); <span class="comment">//执行compilation的build方法进行编译，编译成功之后执行回调</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第四步：执行`Compiler`对象的`run`方法开始执行编译</span></span><br><span class="line">  run(callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hooks.run.call(); <span class="comment">//在编译前触发run钩子执行，表示开始启动编译了</span></span><br><span class="line">    <span class="keyword">const</span> onCompiled = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 第七步：当编译成功后会触发done这个钩子执行</span></span><br><span class="line">      <span class="keyword">this</span>.hooks.done.call();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.compile(onCompiled); <span class="comment">//开始编译，成功之后调用onCompiled</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compilation</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(webpackOptions) &#123;</span><br><span class="line">    <span class="keyword">this</span>.options = webpackOptions;</span><br><span class="line">    <span class="keyword">this</span>.modules = []; <span class="comment">//本次编译所有生成出来的模块</span></span><br><span class="line">    <span class="keyword">this</span>.chunks = []; <span class="comment">//本次编译产出的所有代码块，入口模块和依赖的模块打包在一起为代码块</span></span><br><span class="line">    <span class="keyword">this</span>.assets = &#123;&#125;; <span class="comment">//本次编译产出的资源文件</span></span><br><span class="line">    <span class="keyword">this</span>.fileDependencies = []; <span class="comment">//本次打包涉及到的文件，这里主要是为了实现watch模式下监听文件的变化，文件发生变化后会重新编译</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第六步：执行compilation的build方法进行编译</span></span><br><span class="line">  build(callback) &#123;</span><br><span class="line">  <span class="comment">//这里开始做编译工作，编译成功执行callback</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 编译过程代码省略</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 编译完成后，触发callback回调</span></span><br><span class="line">  callback()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="compiler-与-compilation"><a href="#compiler-与-compilation" class="headerlink" title="compiler 与 compilation"></a>compiler 与 compilation</h3><p>那上面提到的 <code>compiler</code> 对象和 <code>compilation</code> 对象到底是什么呢？又有什么区别与联系？</p>
<ul>
<li><code>compiler</code> 对象包含了webpack的所有配置信息，包括<code>entry</code>、<code>output</code>、<code>module</code>、<code>plugins</code>等，<code>compiler</code> 对象会在启动webpack时，一次性地初始化创建，它是全局唯一的，可以简单理解为webpack的实例。</li>
<li><code>compilation</code> 对象代表一次资源的构建，通过一系列API可以访问/修改本次模块资源、编译生成的资源、变化的文件、以及被跟踪依赖的状态信息等，当我们以开发模式运行webpack时，每当检测到一个文件变化，就会创建一个新的 <code>compilation</code> 对象，所以 <code>compilation</code> 对象也是一次性的，只能用于当前的编译。</li>
</ul>
<p><strong>他有以下主要属性：</strong></p>
<ul>
<li><code>compilation.modules</code> 解析后的所有模块</li>
<li><code>compilation.chunks</code> 所有的代码分块chunk</li>
<li><code>compilation.assets</code> 本次打包生成的所有文件</li>
<li><code>compilation.hooks</code> compilation所有的钩子</li>
</ul>
<p>所以说呢，<code>compiler</code> 代表的是整个 webpack 从启动到关闭的生命周期（终端结束，该生命周期结束）， 而 <code>compilation</code> 只是代表了一次性的编译过程，如果是watch模式，每次监听到文件变化，都会产生一个新的 <code>compilation</code>，所以 <code>compilation</code> 代表一次资源的构建，会多次被创建，而 <code>compiler</code> 只会被创建一次。</p>
<p><strong>我们了解了<code>compiler</code>和<code>compilation</code>对象后，就可以来看一下到底有哪些钩子。</strong></p>
<h3 id="compiler钩子"><a href="#compiler钩子" class="headerlink" title="compiler钩子"></a>compiler钩子</h3><p>compiler有很多钩子<a href="https://webpack.js.org/api/compiler-hooks/#root" target="_blank" rel="noopener">官方地址</a>、<a href="https://webpack.docschina.org/api/compiler-hooks/" target="_blank" rel="noopener">中文地址</a>，介绍几个常用的：</p>
<ul>
<li><code>environment</code> SyncHook类型，在编译器准备环境时调用，时机就在配置文件中初始化插件之后。</li>
<li><code>afterEnvironment</code> SyncHook类型，当编译器环境设置完成后，在 <code>environment hook</code> 后直接调用。</li>
<li><code>entryOption</code> SyncBailHook类型，在 <code>webpack</code> 选项中的 <code>entry</code> 被处理过之后调用。</li>
<li><code>afterPlugins</code> SyncHook类型，在插件初始化之后。</li>
<li><code>afterResolvers</code> SyncHook类型，<code>resolver</code> 设置完成之后触发。</li>
<li><code>beforeRun</code> AsyncSeriesHook类型，在开始执行一次构建之前调用，<code>compiler.run</code> 方法开始执行后立刻进行调用。</li>
<li><code>run</code> AsyncSeriesHook类型，开始编译后触发。</li>
<li><code>watchRun</code> AsyncSeriesHook类型，在监听模式下，一个新的 <code>compilation</code> 触发之后，但在 <code>compilation</code> 实际开始之前触发。</li>
<li><code>beforeCompile</code> AsyncSeriesHook类型，在创建 <code>compilation</code> 参数之后执行。</li>
<li><code>compile</code> SyncHook类型，<code>beforeCompile</code> 之后立即调用，但在一个新的 <code>compilation</code> 创建之前。</li>
<li><code>thisCompilation</code> SyncHook类型，初始化 <code>compilation</code> 时调用，在触发 <code>compilation</code> 事件之前调用。</li>
<li><code>compilation</code> SyncHook类型，一次新的编译 <code>compilation</code> 创建之后触发。</li>
<li><code>make</code> AsyncParallelHook类型，<code>compilation</code> 结束之前执行，<code>seal</code> 之前执行。</li>
<li><code>afterCompile</code> AsyncSeriesHook类型，<code>compilation</code> 结束和封印之后执行。</li>
<li><code>shouldEmit</code> SyncBailHook类型，在输出 <code>asset</code> 之前调用。返回一个布尔值，告知是否输出。</li>
<li><code>emit</code> AsyncSeriesHook类型，生成资源到 <code>output</code> 目录之前触发。</li>
<li><code>afterEmit</code> AsyncSeriesHook类型，输出 <code>asset</code> 到 <code>output</code> 目录之后执行。</li>
<li><code>done</code> AsyncSeriesHook类型，<code>compilation</code> 编译完成后触发。</li>
<li><code>failed</code> SyncHook类型，<code>compilation</code> 编译失败后触发。</li>
</ul>
<h3 id="compilation钩子"><a href="#compilation钩子" class="headerlink" title="compilation钩子"></a>compilation钩子</h3><p>compilation对象也有很多钩子<a href="https://webpack.js.org/api/compilation-hooks/#root" target="_blank" rel="noopener">官方地址</a>、<a href="https://webpack.docschina.org/api/compilation-hooks/" target="_blank" rel="noopener">中文地址</a>，介绍几个常用的：</p>
<ul>
<li><code>buildModule</code> SyncHook类型，模块开始编译前，执行该钩子，可以用于修改模块内容。</li>
<li><code>succeedModule</code> SyncHook类型，模块编译成功后，执行该钩子。</li>
<li><code>finishModules</code> AsyncSeriesHook类型，所有模块编译完成后，执行该钩子。</li>
<li><code>seal</code> SyncHook类型，在构建过程封存前触发，允许在最终资源生成之前进行一些操作。</li>
<li><code>optimize</code> SyncHook类型，优化阶段开始时触发，可以用于自定义资源优化逻辑。</li>
<li><code>optimizeAssets</code> AsyncSeriesHook类型，优化存储在 compilation.assets 中的所有 asset，可以监听和修改资源的优化过程。</li>
<li><code>optimizeChunkAssets</code> AsyncSeriesHook类型，优化所有 chunk asset，弃用，可使用 processAssets 来代替，可用于自定义块资源的优化逻辑。</li>
<li><code>optimizeTree</code> AsyncSeriesHook类型，在优化依赖树之前触发，允许修改资源树的优化逻辑。</li>
<li><code>afterOptimizeTree</code> SyncHook类型，在优化依赖树之后触发，可用于处理优化完成后的资源树。</li>
<li><code>beforeHash</code> SyncHook类型，在计算输出文件的哈希之前触发，可以监听和修改哈希生成的逻辑。</li>
<li><code>afterHash</code> SyncHook类型，在输出文件哈希计算完成后触发，可用于处理生成的哈希值。</li>
<li><code>beforeModuleAssets</code> SyncHook类型，在生成模块资源之前触发，可用于在模块资源生成前执行一些操作。</li>
<li><code>moduleAsset</code> SyncHook类型，在生成模块资源时触发，可监听和修改模块资源的生成。</li>
<li><code>processAssets</code> AsyncSeriesHook类型，asset 处理时触发，可以监听和修改资源的生成。</li>
</ul>
<p>每个钩子都有对应的类型，那这些类型有什么区别呢？</p>
<h2 id="Tapable"><a href="#Tapable" class="headerlink" title="Tapable"></a>Tapable</h2><p><a href="https://github.com/webpack/tapable" target="_blank" rel="noopener">Tapable</a>是一个提供<strong>事件发布订阅</strong>的工具，通过其提供的一系列钩子，我们可以注册事件，然后在不同的阶段去触发这些注册的事件。 webpack的plugin机制正是基于 Tapable 实现的，在不同编译阶段触发不同的钩子。</p>
<p>Tapable 官方文档提供了这九种钩子，也就是我们上面提到的钩子类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  SyncHook,</span><br><span class="line">  SyncBailHook,</span><br><span class="line">  SyncWaterfallHook,</span><br><span class="line">  SyncLoopHook,</span><br><span class="line">  AsyncParallelHook,</span><br><span class="line">  AsyncParallelBailHook,</span><br><span class="line">  AsyncSeriesHook,</span><br><span class="line">  AsyncSeriesBailHook,</span><br><span class="line">  AsyncSeriesWaterfallHook</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">"tapable"</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到，这些钩子有两种开头，分别是 <code>Sync</code> 和 <code>Async</code> ，这两种钩子的区别是： <code>Sync</code> 开头的为同步钩子，表示注册的事件函数会同步进行执行；<code>Async</code> 开头的为异步钩子，表示注册的事件函数会异步进行执行</p>
<p>同时呢，这些钩子还有三种结尾，分别是<code>Hook</code>、<code>BailHook</code>、<code>WaterfallHook</code>、<code>LoopHook</code>，</p>
<p>这三种结尾的区别是如下所示</p>
<ul>
<li><code>Hook</code>结尾的为普通钩子，只会按顺序挨个执行注册的事件，不会去管事件函数的返回值是什么。</li>
</ul>
<p><img src="https://github.com/hankliu62/interview/assets/8088864/dec8ff7b-7561-4d15-b96f-54c6bde1a4ab" alt="image"></p>
<ul>
<li><code>BailHook</code>结尾的为保险钩子，只要注册的事件函数有一个返回值不为<code>undefined</code>，就会停止执行后面的事件函数。</li>
</ul>
<p><img src="https://github.com/hankliu62/interview/assets/8088864/ae6043a5-e389-4c3c-beb7-d56e30bdf1f5" alt="image"></p>
<ul>
<li><code>WaterfallHook</code>结尾的为瀑布钩子，注册的事件函数会按顺序执行，每个事件函数的返回值会作为下一个事件函数的参数，只会影响下一个事件函数的第一个参数。</li>
</ul>
<p><img src="https://github.com/hankliu62/interview/assets/8088864/8e03fb89-5b75-4100-aeb9-bd35fa261143" alt="image"></p>
<ul>
<li><code>LoopHook</code>结尾的为循环钩子，注册的事件函数会按顺序执行，只要执行的事件返回值非<code>undefined</code>，就会立即重头开始执行，直到所有的事件函数都返回<code>undefined</code>，这个钩子才会结束。</li>
</ul>
<p><img src="https://github.com/hankliu62/interview/assets/8088864/c4944703-5add-4ca1-8cb8-34e867b1f2b7" alt="image"></p>
<p>接下来，我们又发现，异步钩子又是以<code>AsyncParallel</code>、<code>AsyncSeries</code>开头，这又有什么区别呢？</p>
<ul>
<li><code>AsyncSeries</code> 为异步串行钩子，注册的事件函数会按顺序挨个执行，每个事件函数执行完后，会调用回调函数，然后再执行下一个事件函数。</li>
<li><code>AsyncParallel</code> 为异步并行钩子，注册的事件函数会同时执行，不会等待上一个事件函数执行完毕后再执行下一个事件函数。</li>
</ul>
<p>下面我们就来讲一下这些钩子如何去使用。</p>
<h3 id="Tapable同步钩子"><a href="#Tapable同步钩子" class="headerlink" title="Tapable同步钩子"></a>Tapable同步钩子</h3><p>同步钩子只需要调用 <code>tap</code> 方法注册事件，然后调用 <code>call</code> 方法触发事件即可。</p>
<h4 id="1-SyncHook"><a href="#1-SyncHook" class="headerlink" title="1. SyncHook"></a>1. SyncHook</h4><p>SyncHook 是一个同步的、普通类型的 Hook，注册的事件函数会按顺序挨个执行，不会去管事件函数的返回值是什么。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SyncHook &#125; = <span class="built_in">require</span>(<span class="string">'tapable'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化钩子，定义形参</span></span><br><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> SyncHook([<span class="string">'name'</span>, <span class="string">'age'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件1</span></span><br><span class="line">hook.tap(<span class="string">'事件1'</span>, (name, age) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'事件1执行:'</span>, name, age);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件2</span></span><br><span class="line">hook.tap(<span class="string">'事件2'</span>, (name, age) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'事件2执行:'</span>, name, age);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件，传入实参</span></span><br><span class="line">hook.call(<span class="string">'前端'</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">// 事件1执行: 前端 18</span></span><br><span class="line"><span class="comment">// 事件2执行: 前端 18</span></span><br></pre></td></tr></table></figure>
<h4 id="2-SyncBailHook"><a href="#2-SyncBailHook" class="headerlink" title="2. SyncBailHook"></a>2. SyncBailHook</h4><p>SyncBailHook 是一个同步的、保险类型的 Hook，意思是只要其中一个有返回了，后面的就不执行了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SyncBailHook &#125; = <span class="built_in">require</span>(<span class="string">'tapable'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化钩子，定义形参</span></span><br><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> SyncBailHook([<span class="string">'name'</span>, <span class="string">'age'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件1</span></span><br><span class="line">hook.tap(<span class="string">'事件1'</span>, (name, age) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'事件1执行:'</span>, name, age);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件2</span></span><br><span class="line">hook.tap(<span class="string">'事件2'</span>, (name, age) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'事件2执行:'</span>, name, age);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'abc'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件3</span></span><br><span class="line">hook.tap(<span class="string">'事件3'</span>, (name, age) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'事件3执行:'</span>, name, age);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件，传入实参</span></span><br><span class="line">hook.call(<span class="string">'前端'</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">// 事件1执行: 前端 18</span></span><br><span class="line"><span class="comment">// 事件2执行: 前端 18</span></span><br></pre></td></tr></table></figure>
<h4 id="3-SyncWaterfallHook"><a href="#3-SyncWaterfallHook" class="headerlink" title="3. SyncWaterfallHook"></a>3. SyncWaterfallHook</h4><p>SyncWaterfallHook 是一个同步的、瀑布类型的 Hook，上一个的返回值会作为下一个的参数,只会影响下一个事件函数的第一个参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SyncWaterfallHook &#125; = <span class="built_in">require</span>(<span class="string">'tapable'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化钩子，定义形参</span></span><br><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> SyncWaterfallHook([<span class="string">'name'</span>, <span class="string">'age'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件1</span></span><br><span class="line">hook.tap(<span class="string">'事件1'</span>, (name, age) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'事件1执行:'</span>, name, age);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'驿站'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件2</span></span><br><span class="line">hook.tap(<span class="string">'事件2'</span>, (name, age) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'事件2执行:'</span>, name, age);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件3</span></span><br><span class="line">hook.tap(<span class="string">'事件3'</span>, (name, age) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'事件3执行:'</span>, name, age);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件，传入实参</span></span><br><span class="line">hook.call(<span class="string">'前端'</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">// 事件1执行: 前端 18</span></span><br><span class="line"><span class="comment">// 事件2执行: 驿站 18</span></span><br><span class="line"><span class="comment">// 事件3执行: 驿站 18</span></span><br></pre></td></tr></table></figure>
<h4 id="4-SyncLoopHook"><a href="#4-SyncLoopHook" class="headerlink" title="4. SyncLoopHook"></a>4. SyncLoopHook</h4><p>SyncLoopHook 是一个同步的、循环类型的 Hook，只要执行的事件函数返回值非undefeind，就会立即重头开始执行，直到所有的事件函数都返回undefined，这个钩子才会结束。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SyncLoopHook &#125; = <span class="built_in">require</span>(<span class="string">'tapable'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化钩子，定义形参</span></span><br><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> SyncLoopHook();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件1</span></span><br><span class="line">hook.tap(<span class="string">'事件1'</span>, () =&gt; &#123;</span><br><span class="line">  count--;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'事件1执行,count为'</span>,count);</span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件2</span></span><br><span class="line">hook.tap(<span class="string">'事件2'</span>, () =&gt; &#123;</span><br><span class="line">  count--;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'事件2执行,count为'</span>,count);</span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件3</span></span><br><span class="line">hook.tap(<span class="string">'事件3'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'事件3执行,count为'</span>,count);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">hook.call();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">// 事件1执行,count为 4</span></span><br><span class="line"><span class="comment">// 事件1执行,count为 3</span></span><br><span class="line"><span class="comment">// 事件2执行,count为 2</span></span><br><span class="line"><span class="comment">// 事件1执行,count为 1</span></span><br><span class="line"><span class="comment">// 事件2执行,count为 0</span></span><br><span class="line"><span class="comment">// 事件3执行,count为 0</span></span><br></pre></td></tr></table></figure>
<h3 id="Tapable异步钩子"><a href="#Tapable异步钩子" class="headerlink" title="Tapable异步钩子"></a>Tapable异步钩子</h3><p>异步钩子提供三种注册的方法：</p>
<ul>
<li><code>tap</code>：以同步方式注册钩子，用 <code>call</code> 来触发，跟同步钩子一样，只不过加持了异步的能力，不过多讲解。</li>
<li><code>tapAsync</code>: 以异步方式注册钩子，用 <code>callAsync</code> 触发，同时也会多一个callback参数，执行callback告诉hook该注册事件已经执行完成，下面有使用示例。</li>
<li><code>tapPromise</code>: 以异步方式注册钩子，用 <code>promise</code> 的方式触发,下面有使用示例。</li>
</ul>
<h4 id="1-AsyncParallelHook"><a href="#1-AsyncParallelHook" class="headerlink" title="1. AsyncParallelHook"></a>1. AsyncParallelHook</h4><p>AsyncParallelHook 是一个异步的、并行类型的 Hook，注册的事件函数会同时执行，不会等待上一个事件函数执行完毕后再执行下一个事件函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; AsyncParallelHook &#125; = <span class="built_in">require</span>(<span class="string">'tapable'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化钩子，定义形参</span></span><br><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> AsyncParallelHook([<span class="string">'name'</span>, <span class="string">'age'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件1</span></span><br><span class="line">hook.tapAsync(<span class="string">'事件1'</span>, (name, age, callback) =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'事件1执行:'</span>, name, age);</span><br><span class="line">    <span class="comment">// 调用callback，表示该事件执行完毕</span></span><br><span class="line">    callback();</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件2</span></span><br><span class="line">hook.tapAsync(<span class="string">'事件2'</span>, (name, age, callback) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'事件2执行:'</span>, name, age);</span><br><span class="line">  <span class="comment">// 调用callback，表示该事件执行完毕</span></span><br><span class="line">  callback();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件3</span></span><br><span class="line">hook.tapAsync(<span class="string">'事件3'</span>, (name, age, callback) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'事件3执行:'</span>, name, age);</span><br><span class="line">  <span class="comment">// 调用callback，表示该事件执行完毕</span></span><br><span class="line">  callback();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件，传入实参</span></span><br><span class="line">hook.callAsync(<span class="string">'前端'</span>, <span class="number">18</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 该钩子注册的所有事件执行完毕后，会执行该回调</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'该钩子所有事件执行完毕'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">// 事件2执行: 前端 18</span></span><br><span class="line"><span class="comment">// 事件3执行: 前端 18</span></span><br><span class="line"><span class="comment">// 2秒后输出：事件1执行: 前端 18</span></span><br><span class="line"><span class="comment">// 该钩子所有事件执行完毕</span></span><br></pre></td></tr></table></figure>
<h4 id="2-AsyncParallelBailHook"><a href="#2-AsyncParallelBailHook" class="headerlink" title="2. AsyncParallelBailHook"></a>2. AsyncParallelBailHook</h4><p>AsyncParallelBailHook 是一个异步、并行的、保险类型的 Hook，只要其中一个有返回了，后面的就不执行了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; AsyncParallelBailHook &#125; = <span class="built_in">require</span>(<span class="string">'tapable'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化钩子，定义形参</span></span><br><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> AsyncParallelBailHook([<span class="string">'name'</span>, <span class="string">'age'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件1</span></span><br><span class="line">hook.tapPromise(<span class="string">'事件1'</span>, (name, age) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'事件1执行:'</span>, name, age);</span><br><span class="line">      resolve(<span class="string">'123'</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件2</span></span><br><span class="line">hook.tapPromise(<span class="string">'事件2'</span>, (name, age) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'事件2执行:'</span>, name, age);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件3</span></span><br><span class="line">hook.tapPromise(<span class="string">'事件3'</span>, (name, age, callback) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'事件3执行:'</span>, name, age);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件，传入实参</span></span><br><span class="line">hook.promise(<span class="string">'前端'</span>, <span class="number">18</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 该钩子注册的所有事件执行完毕后，会执行该回调</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'该钩子所有事件执行完毕'</span>,res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">// 事件3执行: 前端 18</span></span><br><span class="line"><span class="comment">// 2秒后输出：事件1执行: 前端 18</span></span><br><span class="line"><span class="comment">// 该钩子所有事件执行完毕123</span></span><br></pre></td></tr></table></figure>
<h4 id="3-AsyncSeriesHook"><a href="#3-AsyncSeriesHook" class="headerlink" title="3. AsyncSeriesHook"></a>3. AsyncSeriesHook</h4><p>AsyncSeriesHook 是一个异步的、串行类型的 Hook，注册的事件函数会按顺序挨个执行，每个事件函数执行完后，会调用回调函数，然后再执行下一个事件函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; AsyncSeriesHook &#125; = <span class="built_in">require</span>(<span class="string">'tapable'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化钩子，定义形参</span></span><br><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> AsyncSeriesHook([<span class="string">'name'</span>, <span class="string">'age'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件1</span></span><br><span class="line">hook.tapAsync(<span class="string">'事件1'</span>, (name, age, callback) =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'事件1执行:'</span>, name, age);</span><br><span class="line">    <span class="comment">// 调用callback，表示该事件执行完毕</span></span><br><span class="line">    callback(<span class="literal">null</span>, <span class="string">'123'</span>);</span><br><span class="line">  &#125;, <span class="number">4000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件2</span></span><br><span class="line">hook.tapAsync(<span class="string">'事件2'</span>, (name, age, callback) =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'事件2执行:'</span>, name, age);</span><br><span class="line">    <span class="comment">// 调用callback，表示该事件执行完毕</span></span><br><span class="line">    callback();</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件3</span></span><br><span class="line">hook.tapAsync(<span class="string">'事件3'</span>, (name, age, callback) =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'事件3执行:'</span>, name, age);</span><br><span class="line">    <span class="comment">// 调用callback，表示该事件执行完毕</span></span><br><span class="line">    callback();</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件，传入实参</span></span><br><span class="line">hook.callAsync(<span class="string">'前端'</span>, <span class="number">18</span>, (err, result) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 最后结束的事件调用的callback会传入两个参数，第一个参数为错误信息，第二个参数为返回值</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'该钩子所有事件执行完毕'</span>,result);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">// 事件3执行: 前端 18</span></span><br><span class="line"><span class="comment">// 事件2执行: 前端 18</span></span><br><span class="line"><span class="comment">// 事件1执行: 前端 18</span></span><br><span class="line"><span class="comment">// 该钩子所有事件执行完毕123</span></span><br></pre></td></tr></table></figure>
<h4 id="4-AsyncSeriesBailHook"><a href="#4-AsyncSeriesBailHook" class="headerlink" title="4. AsyncSeriesBailHook"></a>4. AsyncSeriesBailHook</h4><p>AsyncSeriesBailHook 是一个异步的、串行的、保险类型的 Hook，只要其中一个有返回了，后面的就不执行了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; AsyncSeriesBailHook &#125; = <span class="built_in">require</span>(<span class="string">'tapable'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化钩子，定义形参</span></span><br><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> AsyncSeriesBailHook([<span class="string">'name'</span>, <span class="string">'age'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件1</span></span><br><span class="line">hook.tapAsync(<span class="string">'事件1'</span>, (name, age, callback) =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'事件1执行:'</span>, name, age);</span><br><span class="line">    <span class="comment">// 调用callback，表示该事件执行完毕</span></span><br><span class="line">    callback();</span><br><span class="line">  &#125;, <span class="number">4000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件2</span></span><br><span class="line">hook.tapAsync(<span class="string">'事件2'</span>, (name, age, callback) =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'事件2执行:'</span>, name, age);</span><br><span class="line">    callback(<span class="literal">null</span>, <span class="string">"88717"</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件3</span></span><br><span class="line">hook.tapAsync(<span class="string">'事件3'</span>, (name, age, callback) =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'事件3执行:'</span>, name, age);</span><br><span class="line">    <span class="comment">// 调用callback，表示该事件执行完毕</span></span><br><span class="line">    callback();</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件，传入实参</span></span><br><span class="line">hook.callAsync(<span class="string">'前端'</span>, <span class="number">18</span>, (err, result) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 最后结束的事件调用的callback会传入两个参数，第一个参数为错误信息，第二个参数为返回值</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'该钩子所有事件执行完毕'</span>,result);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">// 事件3执行: 前端 18</span></span><br><span class="line"><span class="comment">// 事件2执行: 前端 18</span></span><br><span class="line"><span class="comment">// 该钩子所有事件执行完毕88717</span></span><br></pre></td></tr></table></figure>
<h4 id="5-AsyncSeriesWaterfallHook"><a href="#5-AsyncSeriesWaterfallHook" class="headerlink" title="5. AsyncSeriesWaterfallHook"></a>5. AsyncSeriesWaterfallHook</h4><p>AsyncSeriesWaterfallHook 是一个异步的、串行的、瀑布类型的 Hook，上一个的返回值会作为下一个的参数,只会影响下一个事件函数的第一个参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; AsyncSeriesWaterfallHook &#125; = <span class="built_in">require</span>(<span class="string">'tapable'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化钩子，定义形参</span></span><br><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> AsyncSeriesWaterfallHook([<span class="string">'name'</span>, <span class="string">'age'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件1</span></span><br><span class="line">hook.tapAsync(<span class="string">'事件1'</span>, (name, age, callback) =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'事件1执行:'</span>, name, age);</span><br><span class="line">    <span class="comment">// 调用callback，表示该事件执行完毕</span></span><br><span class="line">    callback(<span class="literal">null</span>,<span class="number">3</span>);</span><br><span class="line">  &#125;, <span class="number">4000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件2</span></span><br><span class="line">hook.tapAsync(<span class="string">'事件2'</span>, (name, age, callback) =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'事件2执行:'</span>, name, age);</span><br><span class="line">    callback(<span class="literal">null</span>, <span class="number">2</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件3</span></span><br><span class="line">hook.tapAsync(<span class="string">'事件3'</span>, (name, age, callback) =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'事件3执行:'</span>, name, age);</span><br><span class="line">    <span class="comment">// 调用callback，表示该事件执行完毕</span></span><br><span class="line">    callback(<span class="literal">null</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件，传入实参</span></span><br><span class="line">hook.callAsync(<span class="string">'前端'</span>, <span class="number">18</span>, (err, result) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 最后结束的事件调用的callback会传入两个参数，第一个参数为错误信息，第二个参数为返回值</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'该钩子所有事件执行完毕'</span>,result);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">// 事件3执行: 前端 18</span></span><br><span class="line"><span class="comment">// 事件2执行: 1 18</span></span><br><span class="line"><span class="comment">// 事件1执行: 2 18</span></span><br><span class="line"><span class="comment">// 该钩子所有事件执行完毕3</span></span><br></pre></td></tr></table></figure>
<h3 id="如何自定义plugin"><a href="#如何自定义plugin" class="headerlink" title="如何自定义plugin"></a>如何自定义plugin</h3><p>了解Tapable之后，我们就可以学习如何自定义plugin了。</p>
<p>webpack 插件由以下几部分组成：</p>
<ul>
<li>一个 <code>JavaScript</code> 类 一个构造方法，可以接受一个 <code>options</code> 对象参数</li>
<li>一个 <code>apply</code> 方法，该方法在 <code>webpack</code> 装载这个插件的时候被调用，并且会传入 <code>compiler</code> 对象<br>根据我们的需求，确定要在哪个阶段挂载到哪个钩子上，根据钩子的类型（同步/异步），选择合适的事件注册方式，将需求实现代码注册为事件。</li>
</ul>
<p>事件回调中具体有哪些参数，需要根据钩子的类型去官网查看<a href="https://webpack.js.org/api/compiler-hooks/#root" target="_blank" rel="noopener">官方地址</a>、<a href="https://webpack.docschina.org/api/compiler-hooks/" target="_blank" rel="noopener">中文地址</a>，这里就不一一列举了。</p>
<blockquote>
<p>注意 ： webpack4 可以用 plugin方法来注册插件，webpack5之后被取消了。<br>compiler.plugin(‘emit’, function (compilation, cb) {})</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicPlugin</span></span>&#123;</span><br><span class="line">  <span class="comment">// 在构造函数中获取用户给该插件传入的配置项</span></span><br><span class="line">  <span class="keyword">constructor</span>(options)&#123;</span><br><span class="line">    <span class="keyword">this</span>.options = options;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Webpack 会调用 BasicPlugin 实例的 apply 方法给插件实例传入 compiler 对象</span></span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    <span class="comment">// 注册第1个事件, 这个事件名叫什么都无所谓，只是个标示而已</span></span><br><span class="line">    compiler.hooks.run.tapAsync(<span class="string">'BasicPlugin'</span>, (compiler, callback) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'以异步方式触及 run 钩子。'</span>)</span><br><span class="line">      callback()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册第2个事件</span></span><br><span class="line">    <span class="comment">// 在compiler的compilation钩子上注册一个事件BasicPlugin</span></span><br><span class="line">    compiler.hooks.compilation.tap(<span class="string">'BasicPlugin'</span>, (compilation) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 测试compilation对象在模块构建之前能得到什么</span></span><br><span class="line">      compilation.hooks.buildModule.tap(<span class="string">'BasicPlugin'</span>, (data) =&gt; &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(data);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册第3个事件</span></span><br><span class="line">    compiler.hooks.emit.tap(<span class="string">'BasicPlugin'</span>, (compilation) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 业务逻辑代码</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = BasicPlugin;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> BasicPlugin = <span class="built_in">require</span>(<span class="string">'./BasicPlugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> BasicPlugin(),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义plugin实战"><a href="#自定义plugin实战" class="headerlink" title="自定义plugin实战"></a>自定义plugin实战</h3><p>为了更好的实践，给大家提供3个自定义插件来参考。</p>
<h4 id="1-FileListPlugin"><a href="#1-FileListPlugin" class="headerlink" title="1. FileListPlugin"></a>1. FileListPlugin</h4><p>需求：在打包完成后，生成一个<code>fileList.md</code>文件，文件内容为打包生成的所有文件名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 一共有2个文件</span><br><span class="line"></span><br><span class="line">- main.bundle.js</span><br><span class="line">- index.html</span><br></pre></td></tr></table></figure>
<p>代码实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FileListPlugin</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.options = options || &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.filename = <span class="keyword">this</span>.options.filename || <span class="string">'fileList.md'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FileListPlugin.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">compiler</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1.通过compiler.hooks.emit.tapAsync()来触发生成资源到output目录之前的钩子，且回调函数会有两个参数，一个是compilation，一个是cb回调函数</span></span><br><span class="line">  compiler.hooks.emit.tapAsync(<span class="string">'FileListPlugin'</span>, (compilation, cb) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 2.要生成的markdown文件的名称</span></span><br><span class="line">    <span class="keyword">const</span> fileListName = <span class="keyword">this</span>.filename;</span><br><span class="line">    <span class="comment">// 3.通过compilation.assets获取到所有待生成的文件，这里是获取它的长度</span></span><br><span class="line">    <span class="keyword">let</span> len = <span class="built_in">Object</span>.keys(compilation.assets).length;</span><br><span class="line">    <span class="comment">// 4.定义markdown文件的内容，也就是先定义一个一级标题，\n表示的是换行符</span></span><br><span class="line">    <span class="keyword">let</span> content = <span class="string">`# 一共有<span class="subst">$&#123;len&#125;</span>个文件\n\n`</span>;</span><br><span class="line">    <span class="comment">// 5.将每一项文件的名称写入markdown文件内</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> filename <span class="keyword">in</span> compilation.assets) &#123;</span><br><span class="line">      content += <span class="string">`- <span class="subst">$&#123;filename&#125;</span>\n`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.给我们即将生成的dist文件夹里添加一个新的资源，资源的名称就是fileListName变量</span></span><br><span class="line">    compilation.assets[fileListName] = &#123;</span><br><span class="line">      <span class="comment">// 7.写入资源的内容</span></span><br><span class="line">      source: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 8.指定新资源的大小，用于webpack展示</span></span><br><span class="line">      size: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content.length;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 9.由于我们使用的是tapAsync异步调用，所以必须执行一个回调函数cb，否则打包后就只会创建一个空的dist文件夹。</span></span><br><span class="line">    cb();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = FileListPlugin;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="keyword">new</span> FileListPlugin(&#123;</span><br><span class="line">    filename: <span class="string">'fileList.md'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-CompressAssetsPlugin"><a href="#2-CompressAssetsPlugin" class="headerlink" title="2. CompressAssetsPlugin"></a>2. CompressAssetsPlugin</h4><p>需求：每次打包完成后，将打包生成的文件生成一个压缩包。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> JSZip = <span class="built_in">require</span>(<span class="string">'jszip'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; RawSource &#125; = <span class="built_in">require</span>(<span class="string">'webpack-sources'</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  将本次打包的资源都打包成为一个压缩包</span></span><br><span class="line"><span class="comment">  需求:获取所有打包后的资源</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pluginName = <span class="string">'CompressAssetsPlugin'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompressAssetsPlugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(&#123; output &#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.output = output;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    <span class="comment">// AsyncSeriesHook 将 assets 输出到 output 目录之前调用该钩子</span></span><br><span class="line">    compiler.hooks.emit.tapAsync(pluginName, (compilation, callback) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 创建zip对象</span></span><br><span class="line">      <span class="keyword">const</span> zip = <span class="keyword">new</span> JSZip();</span><br><span class="line">      <span class="comment">// 获取本次打包生成所有的assets资源</span></span><br><span class="line">      <span class="keyword">const</span> assets = compilation.getAssets();</span><br><span class="line">      <span class="comment">// 循环每一个资源</span></span><br><span class="line">      assets.forEach(<span class="function">(<span class="params">&#123; name, source &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 调用source()方法获得对应的源代码 这是一个源代码的字符串</span></span><br><span class="line">        <span class="keyword">const</span> sourceCode = source.source();</span><br><span class="line">        <span class="comment">// 往 zip 对象中添加资源名称和源代码内容</span></span><br><span class="line">        zip.file(name, sourceCode);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 调用 zip.generateAsync 生成 zip 压缩包</span></span><br><span class="line">      zip.generateAsync(&#123; <span class="attr">type</span>: <span class="string">'nodebuffer'</span> &#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 通过 new RawSource 创建压缩包</span></span><br><span class="line">        <span class="comment">// 并且同时通过 compilation.emitAsset 方法将生成的 Zip 压缩包输出到 this.output</span></span><br><span class="line">        compilation.emitAsset(<span class="keyword">this</span>.output, <span class="keyword">new</span> RawSource(result));</span><br><span class="line">        <span class="comment">// 调用 callback 表示本次事件函数结束</span></span><br><span class="line">        callback();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = CompressAssetsPlugin;</span><br></pre></td></tr></table></figure>
<h4 id="3-BundleSizeWebpackPlugin"><a href="#3-BundleSizeWebpackPlugin" class="headerlink" title="3. BundleSizeWebpackPlugin"></a>3. BundleSizeWebpackPlugin</h4><p>需求：文件超过一定大小时给出警告</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BundleSizeWebpackPlugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.options = options</span><br><span class="line">  &#125;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; sizeLimit &#125; = <span class="keyword">this</span>.options</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bundle size plugin'</span>)</span><br><span class="line">    <span class="comment">// 在编译完成后，执行回调，拿到打包后文件路径，然后读取文件信息获取文件大小，然后定义一些逻辑</span></span><br><span class="line">    compiler.hooks.done.tap(<span class="string">'BundleSizePlugin'</span>, stats =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; path, filename &#125; = stats.compilation.outputOptions</span><br><span class="line">      <span class="keyword">const</span> bundlePath = resolve(path, filename)</span><br><span class="line">      <span class="keyword">const</span> &#123; size &#125; = fs.statSync(bundlePath)</span><br><span class="line">      <span class="keyword">const</span> bundleSize = size / <span class="number">1024</span></span><br><span class="line">      <span class="keyword">if</span> (bundleSize &lt; sizeLimit) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">          <span class="string">'safe: bundle-size'</span>,</span><br><span class="line">          bundleSize,</span><br><span class="line">          <span class="string">'\n size limit: '</span>,</span><br><span class="line">          sizeLimit</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(</span><br><span class="line">          <span class="string">'unsafe: bundle-size'</span>,</span><br><span class="line">          bundleSize,</span><br><span class="line">          <span class="string">'\n size limit: '</span>,</span><br><span class="line">          sizeLimit</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = BundleSizeWebpackPlugin</span><br></pre></td></tr></table></figure>
<h3 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h3><p>目前，webpack社区已经有很多成熟的插件了，如果非特殊需求，不用自定义插件。下面介绍几个常用的插件。</p>
<h4 id="1-html-webpack-plugin"><a href="#1-html-webpack-plugin" class="headerlink" title="1. html-webpack-plugin"></a>1. html-webpack-plugin</h4><p><code>html-webpack-plugin</code>可以在打包结束后，自动生成一个html文件，并把打包生成的js自动引入到这个html文件中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">      template: path.join(__dirname, <span class="string">'/index.html'</span>),</span><br><span class="line">      minify: &#123;</span><br><span class="line">        <span class="comment">// 压缩HTML文件</span></span><br><span class="line">        removeComments: <span class="literal">true</span>, <span class="comment">// 移除HTML中的注释</span></span><br><span class="line">        collapseWhitespace: <span class="literal">true</span>, <span class="comment">// 删除空白符与换行符</span></span><br><span class="line">        minifyCSS: <span class="literal">true</span>, <span class="comment">// 压缩内联css</span></span><br><span class="line">      &#125;,</span><br><span class="line">      inject: <span class="literal">true</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>inject 有四个选项值</strong></p>
<ul>
<li><code>true</code>：默认值，<em>script</em> 标签位于 <em>html</em> 文件的 <em>body</em> 底部</li>
<li><code>body</code>：<em>script</em> 标签位于 <em>html</em> 文件的 <em>body</em> 底部（同 <em>true</em>）</li>
<li><code>head</code>：<em>script</em> 标签位于 <em>head</em> 标签内</li>
<li><code>false</code>：不插入生成的 <em>js</em> 文件，只是单纯的生成一个 <em>html</em> 文件</li>
</ul>
<h4 id="2-clean-webpack-plugin"><a href="#2-clean-webpack-plugin" class="headerlink" title="2. clean-webpack-plugin"></a>2. clean-webpack-plugin</h4><p><code>clean-webpack-plugin</code> 用于在打包前清理上一次项目生成的 <code>bundle</code> 文件，它会根据 <code>output.path</code> 自动清理文件夹。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: path.join(__dirname, <span class="string">'/index.html'</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(), <span class="comment">// 所要清理的文件夹名称</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-extract-text-webpack-plugin"><a href="#3-extract-text-webpack-plugin" class="headerlink" title="3. extract-text-webpack-plugin"></a>3. extract-text-webpack-plugin</h4><p>将css样式从js文件中提取出来最终合成一个css文件，该插件只支持webpack4之前的版本，如果你当前是webpack4及以上版本那么就会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> extractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: extractTextPlugin.extract(&#123;</span><br><span class="line">          fallback: <span class="string">"style-loader"</span>,</span><br><span class="line">          use: <span class="string">"css-loader"</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> extractTextPlugin(&#123;</span><br><span class="line">      filename: <span class="string">"[name].css"</span>,</span><br><span class="line">      allChunks: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-mini-css-extract-plugin"><a href="#4-mini-css-extract-plugin" class="headerlink" title="4. mini-css-extract-plugin"></a>4. mini-css-extract-plugin</h4><p>该插件与上面的<code>extract-text-webpack-plugin</code>的一样，都是将css样式提取出来, 唯一就是用法不同，本插件的webpack4版本之后推荐使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          <span class="string">"css-loader"</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">"css/[name].css"</span>,</span><br><span class="line">      chunkFilename: <span class="string">"css/[name].css"</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-purifycss-webpack"><a href="#5-purifycss-webpack" class="headerlink" title="5. purifycss-webpack"></a>5. purifycss-webpack</h4><p>有时候我们 css 写得多了或者重复了，这就造成了多余的代码，我们希望在生产环境进行去除。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> PurifyCssWebpack = <span class="built_in">require</span>(<span class="string">'purifycss-webpack'</span>) <span class="comment">// 引入PurifyCssWebpack插件</span></span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>) <span class="comment">// 引入glob模块,用于扫描全部html文件中所引用的css</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(common, &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> PurifyCssWebpack(&#123;</span><br><span class="line">      paths: glob.sync(path.join(__dirname, <span class="string">'src/*.html'</span>)),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="6-optimize-css-assets-webpack-plugin"><a href="#6-optimize-css-assets-webpack-plugin" class="headerlink" title="6. optimize-css-assets-webpack-plugin"></a>6. optimize-css-assets-webpack-plugin</h4><p><code>optimize-css-assets-webpack-plugin</code> 用于优化和最小化 css 的插件，它会压缩 css，但是不会像 cssnano 那样移除或合并样式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">"optimize-css-assets-webpack-plugin"</span>) <span class="comment">// 压缩css代码</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimizer: [</span><br><span class="line">      <span class="comment">// 压缩css</span></span><br><span class="line">      <span class="keyword">new</span> OptimizeCSSAssetsPlugin(&#123;&#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-DefinePlugin"><a href="#7-DefinePlugin" class="headerlink" title="7. DefinePlugin"></a>7. DefinePlugin</h4><p>用于注入全局变量，一般用在环境变量上。无需安装，webpack内置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> Webpack.DefinePlugin(&#123;</span><br><span class="line">      STR: <span class="built_in">JSON</span>.stringify(<span class="string">"蛙人"</span>),</span><br><span class="line">      <span class="string">"process.env"</span>: <span class="built_in">JSON</span>.stringify(<span class="string">"dev"</span>),</span><br><span class="line">      name: <span class="string">"蛙人"</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-copy-webpack-plugin"><a href="#8-copy-webpack-plugin" class="headerlink" title="8. copy-webpack-plugin"></a>8. copy-webpack-plugin</h4><p><code>copy-webpack-plugin</code> 用于在 webpack 中拷贝文件和文件夹，比如我们需要把一些静态文件拷贝到打包目录，这时候就可以使用这个插件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">'copy-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin(&#123;</span><br><span class="line">      patterns: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">from</span>: <span class="string">'public/js/*.js'</span>,</span><br><span class="line">          to: path.resolve(__dirname, <span class="string">'dist'</span>, <span class="string">'js'</span>),</span><br><span class="line">          flatten: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-imagemin-webpack-plugin"><a href="#9-imagemin-webpack-plugin" class="headerlink" title="9. imagemin-webpack-plugin"></a>9. imagemin-webpack-plugin</h4><p>用于压缩图片。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ImageminPlugin =  <span class="built_in">require</span>(<span class="string">'imagemin-webpack-plugin'</span>).default</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> ImageminPlugin(&#123;</span><br><span class="line">        test: <span class="regexp">/\.(jpe?g|png|gif|svg)$/i</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源：<a href="https://zhuanlan.zhihu.com/p/661670534" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/661670534</a></p>

      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/">webpack</a></li></ul>

        <a data-url="https://hankliu62.github.io/2024/03/05/webpack-plugin-mechanism/" data-id="cluersklw000wuflootmitt4i" class="article-share-link">Share</a>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/03/06/mobile-debugging-tools/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          H5 移动端调试工具汇总
        
      </div>
    </a>
  
  
    <a href="/2024/02/29/commomly-css/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">常用的CSS技巧</div>
    </a>
  
</nav>

  
</article>


</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/04/02/security-anti-reptile/">Web安全之静态内容防爬虫</a>
          </li>
        
          <li>
            <a href="/2024/03/31/security-sql-injection/">Web安全之 SQL 注入</a>
          </li>
        
          <li>
            <a href="/2024/03/30/thread-loader/">thread-loader</a>
          </li>
        
          <li>
            <a href="/2024/03/29/vitepress-blog-guide/">使用VitePress搭建个人博客</a>
          </li>
        
          <li>
            <a href="/2024/03/27/security-csrf/">Web安全之 CSRF 攻击</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/blog/">blog</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/csrf/">csrf</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debugging/">debugging</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/">github</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github-pages/">github pages</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/interview/">interview</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/loader/">loader</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mobile/">mobile</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/">network</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reptile/">reptile</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/security/">security</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/">shell</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/">sql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ubuntu/">ubuntu</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vitepress/">vitepress</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/">webpack</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/weinre/">weinre</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xss/">xss</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">四月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">三月 2024</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">二月 2024</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2024 HankLiu, Inc. All rights reserved.<br>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">文章</a>
  
    <a href="/toolbox-frontend" class="mobile-nav-link">小工具</a>
  
    <a href="/resume" class="mobile-nav-link">小简介</a>
  
  <a href="#search" class="mobile-nav-link st-search-show-outputs">Search</a>
</nav>
  

<!-- totop start -->
<div id="totop">
	<a title="To Top"></a>
</div>
<!-- totop end -->

<!-- swiftype search start -->

<!-- swiftype search end -->



<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/lrsjng.jquery-qrcode/0.12.0/jquery.qrcode.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

</div>
</body>
</html>
